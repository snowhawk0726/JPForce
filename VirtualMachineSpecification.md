# 仮想マシンの仕様

本ドキュメントは、日本語ふぉーす(JPForce)における仮想マシン(Virtual Machine、以下 VM)の仕様について、命令セット(Instruction Set）を中心に説明します。

## 動作原理

VM は、バイトコードに変換された命令語を逐次実行します。

それぞれの命令語は、命令を表す１バイトのオペコードと、データへの参照やデータの数、または飛び先等を表す１〜２バイトのオペランドからなります。

また、各命令は、ふぉーすと同様データのアクセスにスタックを利用します。すなわち、データを入力としてスタックに積み、それを各命令で処理し、結果をスタックに出力し、その繰り返しで処理を行います。

## 参照するデータ

VM は、翻訳器が生成した定数表、および実行時の大域変数表、スタック、局所変数、自由変数などを参照・アクセスして動作します。
参照・アクセスするデータは、ふぉーすのオブジェクトです。

各データは、翻訳時に、識別子名等からインデックス(変数表等の位置)に変換されたオペランドを使って、参照・アクセスされます。

以下に、VM で使用するデータ(領域・表)を示します。

### スタック(Stack)

命令語が入出力を行うオブジェクトを格納する領域です。関数の入力や、局所変数もここで行います。

### 定数表(Constant table)

翻訳器がコンパイル時に生成する定数オブジェクトの表です。  
扱える定数は最大 65,535 個です。

### 大域変数表(Global variable table)

VM が実行時に、大域(Global scope)に属するオブジェクトをアクセスします。  
扱える変数は最大 65,535 個です。

### 局所変数(Local scope variable)

関数等で使用される局所的なオブジェクトで、スタック領域に格納されます。  
扱える変数は最大 256 個です。

### 自由変数(Free variable)

クロージャでアクセスするオブジェクトで、クロージャ・オブジェクトに格納され、関数等が参照します。  
扱える変数は最大 256 個です。

## 命令セット(Instruction Set)

VM で使用する命令セットは表の様になります。  
(＊：オペランドの括弧内の数字は、オペランドのバイト数)

| ##  | オペコード       | 第１オペランド(バイト数) | 第２オペランド(バイト数) | 仕様                                                                                                                           |
| --- | :--------------- | :----------------------- | :----------------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| 00  | OpConstant       | 定数表位置(2)            | -                        | 定数(オブジェクト)をスタックに積む                                                                                             |
| 01  | OpSetGlobal      | 大域変数位置(2)          | -                        | 　スタックのオブジェクトを大域変数表に格納する                                                                                 |
| 02  | OpGetGlobal      | 大域変数位置(2)          | -                        | 　大域変数表のオブジェクトをスタックに積む                                                                                     |
| 03  | OpSetLocal       | 局所変数位置(1)          | -                        | 局所変数を局所変数位置に格納する                                                                                               |
| 04  | OpGetLocal       | 局所変数位置(1)          | -                        | 局所変数位置のオブジェクトをスタックに積む                                                                                     |
| 05  | OpPop            | -                        | -                        | スタックのオブジェクトを捨てる(未使用)                                                                                         |
| 06  | OpPhrase         | 格インデックス(1)        | -                        | 指定の格とスタックのオブジェクトで`句`を形成する                                                                               |
| 07  | OpTrue           | -                        | -                        | スタックに`真`(オブジェクト)を積む                                                                                             |
| 08  | OpFalse          | -                        | -                        | スタックに`偽`(オブジェクト)を積む                                                                                             |
| 09  | OpNull           | -                        | -                        | スタックに`無`(オブジェクト)を積む                                                                                             |
| 10  | OpArray          | 要素数(2)                | -                        | 指定の要素数を持つ配列をスタックに積む(要素はスタックから得る)                                                                 |
| 11  | OpDictionary     | 要素数(2)                | -                        | 指定の要素数を持つ辞書をスタックに積む(要素はスタックから得る)                                                                 |
| 12  | OpGenitive       | -                        | -                        | スタックに積んだオブジェクトに、スタックに積んだもう一つのオブジェクトを使ってアクセスをし、結果を返す(例：配列要素のアクセス) |
| 13  | OpJump           | 飛び先(2)                | -                        | 飛び先に IP を進める                                                                                                           |
| 14  | OpJumpNotTruthy  | 飛び先(2)                | -                        | スタックの値が`真`でない場合に飛び先に IP を進める                                                                             |
| 15  | OpCall           | -                        | -                        | スタックのクロージャ(翻訳済み関数)を実行する                                                                                   |
| 16  | OpReturnValue    | -                        | -                        | 関数の終了処理を行い、値を返す(スタックに値を積む)                                                                             |
| 17  | OpReturn         | -                        | -                        | 関数の終了処理を行う                                                                                                           |
| 18  | OpPredicate      | 述語インデックス(1)      | -                        | 指定の述語を実行する                                                                                                           |
| 19  | OpGetProperty    | 属性インデックス(1)      | -                        | スタックのオブジェクトの(指定の)属性を得る                                                                                     |
| 20  | OpClosure        | 定数表位置(2)            | 自由変数数(1)            | 定数表から関数と、スタックから指定数の自由変数を得て、クロージャを作成し、スタックに積む                                       |
| 21  | OpGetFree        | 自由変数位置(1)          | -                        | 現在のクロージャから、指定の自由変数を得て、スタックに積む                                                                     |
| 22  | OpCurrentClosure | -                        | -                        | コンパイル中のクロージャをスタックに積む                                                                                       |

以下に、命令語の補足をします。

### 格、述語、属性インデックスを持つ命令語

`OpPhrase`、`OpPredicate`、`OpGetProperty`がアクセスするデータは、内部的に静的な配列として実装しており、それぞれ、格、述語(識別子名)、属性(識別子名)が翻訳時に配列のインデックスに変換されます。  
VM は、これらのインデックスにより、処理を取り出し、実行します。

`OpPhraseに`は、インデックスから得た`格`を、スタックに積まれた値と合わせて動的に`句`(Phrase)を生成し、スタックに積みます。

### 定数オブジェクトを表す命令語

`OpTrue`、`OpFalse`、`OpNull`は、それぞれ`真`、`偽`、`無`のオブジェクトをスタックに積みます。`OpConstant`の様に、インデックスで値を取り出すことなく効率的にオブジェクトを扱えます。

### 要素数を持つ命令語

`OpArray`、`OpDictionary`は、スタックに積まれた要素数分のオブジェクトを要素として、それぞれ`配列`、`辞書`オブジェクトを生成し、スタックに積みます。  
扱える要素数は最大 65,535 個です。  
ただし、`辞書`は、`キー`と`値`で１つの要素であるため、実際の`辞書`の要素数は指定の半分になります。

### 飛び先を持つ命令語

翻訳されたバイトコードを実行する際、VM は、その実行位置をインストラクション・ポイント(IP)として管理しており、命令語を実行すると IP を進め、逐次処理を行います。  
`OpJump`、`OpJumpNotTruty`は、それぞれ無条件、条件によって、IP に飛び先アドレスをセットすることにより、処理を分岐します。

### 属格のアクセス

ふぉーすでは、`<オブジェクト１>の<オブジェクト２>`の様に、`オブジェクト１`の要素を`オブジェクト２`でアクセスし結果を得ます。  
`OpGenitive`は、２つのスタックから属格の値を得ます。

### 関数関連の命令語

関数は、コンパイル時に、その処理がバイトコードに変換され`翻訳済み関数`オブジェクトが生成され、定数表に格納されます。

#### 呼び出しと返り処理

`OpCall`は、述語`実行`、`する`、`実行する`による関数を実行します。  
`OpReturn`、`OpReturnValue`は、それぞれ述語`返る`、`返す`を実行します。  
暗黙的に(値を返さずに)、関数を終了し、元の処理に戻る合は、`OpReturn`が実行されます。

#### クロージャ

VM では、すべての関数を`クロージャ`として扱います。

`OpClosure`では、オペランドから定数表にある`翻訳済み関数`と、スタック領域にある指定の自由変数を得て、`クロージャ`オブジェクトを生成し、スタックに積みます。  
積まれた`クロージャ`は、関数実行時に、`翻訳済み関数`を取り出し、引数や局所変数の割り当てを行い、VM が`翻訳済み関数`のバイトコードを実行します。

`OpGetFree`では、クロージャから自由変数を取り出し、スタックに積みます。  
`OpCurrentClosure`では、再帰処理で使われ、現在処理中のクロージャを取り出し、スタックに積みます。

## 命令語の使用例(サンプル)

`REPL`で実行したサンプルを、`翻訳結果`に基づき説明します。

### 定数式の計算

以下の様に、定数を計算する場合、翻訳器は可能な限り内部で計算をし、結果だけを定数として出力します。

```
>> 5と2を掛け、10を足す
翻訳結果：
0000 OpConstant 0	: 20(数値)

実行結果: 20
入力: (20)
>>
```

0 番地の`OpConstant`で、定数表の計算結果をスタックに積みます。

### 定数、大域変数による足し算

識別子に設定した値を取り出し、足します。

```
>> aは１。bは2。aとbを足す。
翻訳結果：
0000 OpConstant 0	: 1(数値)
0003 OpSetGlobal 0	: a(識別子名)
0006 OpConstant 1	: 2(数値)
0009 OpSetGlobal 1	: b(識別子名)
0012 OpGetGlobal 0	: a(識別子名)
0015 OpPhrase 5		: と(格)
0017 OpGetGlobal 1	: b(識別子名)
0020 OpPhrase 2		: を(格)
0022 OpPredicate 24	: 足す

実行結果: 3
入力: (3)
>>
```

1. 0〜9 番地:  
   識別子`a`と`b`に値を設定します。(`OpConstant`、`OpSetGlobal`)
2. 12〜20 番地:  
   それらを大域変数表から取り出し(`OpGetGlobal`)、格`と`、`を`と合わせて、スタックに積みます。(`OpPhrase`)
3. 22 番地：  
   述語`足す`を実行します。(`OpPredicate`)

### 真偽と否定

`真`を 2 回否定します。

```
>> aは真。aでなくない。
翻訳結果：
0000 OpTrue
0001 OpSetGlobal 0	: a(識別子名)
0004 OpGetGlobal 0	: a(識別子名)
0007 OpPhrase 4		: で(格)
0009 OpPredicate 33	: ない
0011 OpPredicate 33	: ない

実行結果: 真
入力: (真)
>>
```

1. 0〜1 番地：  
   `真`を識別子`a`に設定します。(`OpTrue`、`OpSetGlobal`)
2. 4〜7 番地：  
   `a`から値を取り出し、格`で`と合わせて`句`を作ります。(`OpGetGlobal`、`OpPhrase`)
3. 9〜11 番地：  
   スタックの値を否定し、さらに、否定します。(`OpPredicate`)

### 配列と属性

３つの要素を持つ配列を識別子`a`に設定し、最初の要素を取り出します。

```
>> aは配列【１、２、３】。aの最初
翻訳結果：
0000 OpConstant 0	: 1(数値)
0003 OpConstant 1	: 2(数値)
0006 OpConstant 2	: 3(数値)
0009 OpArray 3
0012 OpSetGlobal 0	: a(識別子名)
0015 OpGetGlobal 0	: a(識別子名)
0018 OpGetProperty 10	: 最初

実行結果: 1
入力: (1)
>>
```

1. 0〜6 番地：  
   配列の要素(1 と 2 と 3)を、定数表から取り出しスタックに積み(`OpConstant`)ます。
2. 9 番地：  
   スタックにある３つの要素を持つ`配列`オブジェクトを生成し、スタックに積みます。(`OpArray`)
3. 12 番地：  
   大域変数表に格納します。(`OpSetGlobal`)
4. 15〜18 番地:  
   大域変数表から取り出し(`OpGetGlobal`)、属性`最初`を得ます。(`OpGetProperty`)

### 辞書の値

属格`の`により、`辞書`リテラルから、値を得ます。

```
>> iは１。辞書【１が「あ」、２が「い」】のi。
翻訳結果：
0000 OpConstant 0	: 1(数値)
0003 OpSetGlobal 0	: i(識別子名)
0006 OpConstant 1	: 1(数値)
0009 OpConstant 2	: あ(文字列)
0012 OpConstant 3	: 2(数値)
0015 OpConstant 4	: い(文字列)
0018 OpDictionary 4
0021 OpGetGlobal 0	: i(識別子名)
0024 OpGenitive

実行結果: あ
入力: (あ)
>>
```

1. 0〜3 番地：  
   数値`1`を識別子`i`に設定します。(`OpConstant`、`OpSetGlobal`)
2. 6〜18 番地：  
   ４つの定数`1`、`あ`、`2`、`い`をスタックに積み、`辞書`オブジェクトを生成します。(`OpConstant`、`OpDictionary`)
3. 21 番地：  
   辞書をアクセスする識別子`i`を取得します。(`OpGetGlobal`)
4. 24 番地：  
   スタックに積まれた`辞書`のキー`i`の値を取得します。(`OpGenitive`)

### 関数定義と実行

２つの関数定義(`one`と`two`)を行い、呼び出し、結果を足します。

```
>> oneは、関数【１】。twoは、関数【２】。oneを実行し、twoを実行し、足す。
翻訳結果：
0000 OpClosure 1, 0	: 翻訳済み関数であって、【入力が、0個。本体が、00 00 00 17】(翻訳済み関数)
0004 OpSetGlobal 0	: one(識別子名)
0007 OpClosure 3, 0	: 翻訳済み関数であって、【入力が、0個。本体が、00 00 02 17】(翻訳済み関数)
0011 OpSetGlobal 1	: two(識別子名)
0014 OpGetGlobal 0	: one(識別子名)
0017 OpCall
0018 OpGetGlobal 1	: two(識別子名)
0021 OpCall
0022 OpPredicate 24	: 足す

翻訳済み関数(1)：
0000 OpConstant 0	: 1(数値)
0003 OpReturn

翻訳済み関数(3)：
0000 OpConstant 2	: 2(数値)
0003 OpReturn

実行結果: 3
入力: (3)
>>
```

1. 0〜4 番地：  
   定数表にある翻訳済み関数を、`one`に設定します。(`OpClosure`、`OpSetGlobal`)  
   `OpClosure`の第１オペランド=1 は、定数表(位置 1)の翻訳済み関数、第２オペランド=0 は自由変数が無いことを示します。
2. 7〜11 番地：  
   同じく、定数表にある翻訳済み関数を、`two`に設定します。(`OpClosure`、`OpSetGlobal`)  
   結果はスタックに積まれます。
3. 14〜17 番地：  
   `one`から関数を取り出し実行します。(`OpGetGlobal`、`OpCall`)  
   結果はスタックに積まれます。
4. 18〜21 番地：  
   `two`から関数を取り出し実行します。(`OpGetGlobal`、`OpCall`)  
   結果はスタックに積まれます。
5. 22 番地:  
   スタックの結果を足します。(`OpPredicate`)
6. 翻訳済み関数(1)：  
   上記、0 番地の`翻訳済み関数`の逆アセンブル表示です。  
   定数`1`をスタックに積み(`OpConstant`)、呼び元に戻ります。(`OpReturn`)
7. 翻訳済み関数(3)：  
   上記、7 番地の`翻訳済み関数`の逆アセンブル表示です。  
   定数`2`をスタックに積み(`OpConstant`)、呼び元に戻ります。(`OpReturn`)

### クロージャと自由変数

`自由変数`を持つ`クロージャ`の例です。  
識別子`newAdder`に内部関数を返す定義をし、識別子`newAdder`を実行することにより内部関数を識別子`adder` に取り出し、それを実行します。  
`adder`は、`newAdder`の２つの入力`a`と`b`を、`1`と`2`として保持し、自身の入力`8`と足すことにより、結果`11`を得ます。

```
>> newAdderは、関数【入力がaとb。関数【入力がc。aとbとcを足す】】。adderは、1と2で、newAdderを実行。8でadderを実行。
翻訳結果：
0000 OpClosure 1, 0	: 翻訳済み関数であって、【入力が、2個。本体が、04 00 04 01 20 00 00 02 17】(翻訳済み関数)
0004 OpSetGlobal 0	: newAdder(識別子名)
0007 OpConstant 2	: 1と(句)
0010 OpConstant 3	: 2で(句)
0013 OpGetGlobal 0	: newAdder(識別子名)
0016 OpCall
0017 OpSetGlobal 1	: adder(識別子名)
0020 OpConstant 4	: 8で(句)
0023 OpGetGlobal 1	: adder(識別子名)
0026 OpCall

翻訳済み関数(0)：
0000 OpGetFree 0	: ??(識別子名)
0002 OpPhrase 5		: と(格)
0004 OpGetFree 1	: ??(識別子名)
0006 OpPhrase 5		: と(格)
0008 OpGetLocal 0	: ??(識別子名)
0010 OpPhrase 2		: を(格)
0012 OpPredicate 24	: 足す
0014 OpReturn

翻訳済み関数(1)：
0000 OpGetLocal 0	: ??(識別子名)
0002 OpGetLocal 1	: ??(識別子名)
0004 OpClosure 0, 2	: 翻訳済み関数であって、【入力が、1個。本体が、21 00 06 05 21 01 06 05 04 00 06 02 18 24 17】(翻訳済み関数)
0008 OpReturn

実行結果: 11
入力: (11)
>>
```

1. 0〜4 番地：  
   `翻訳済み関数(1)`を含むクロージャを、識別子`newAdder`に設定します。(`OpClosure`、`OpSetGlobal`)
2. 7〜10 番地：  
   句`1と`、`2で`を定数表から取り出しスタックに積みます。(`OpConstant`)
3. 13〜17 番地：  
   識別子`newAdder`から関数を取り出し実行します。(`OpGetGlobal`、`OpCall`)  
   結果を、識別子`adder`に設定します。(`OpSetGlobal`)
4. 20 番地：  
   句`8で`を定数表から取り出しスタックに積みます。(`OpConstant`)
5. 23〜26 番地:  
   識別子`adder`から関数を取り出し実行します。(`OpGetGlobal`、`OpCall`)
6. 翻訳済み関数(0)：  
   `翻訳済み関数(1)`の 4 番地の`翻訳済み関数`の逆アセンブル表示です。
   1. 0〜6 番地：  
      `クロージャ`から自由変数`a`と`b`の値を取り出し(`OpGetFree`)、格`と`と合わせてスタックに積みます。(`OpPhrase`)  
      (自由変数は外側の関数の入力であり、内側の当該関数の入力ではありません。)
   2. 8〜10 番地：  
      入力`c`をスタックに積み(`OpGetLocal`)、格`を`と合わせてスタックに積みます。(`OpPhrase`)
   3. 12 番地：  
      ３つの値を足します。(`OpPredicate`)
   4. 14 番地：  
      呼び元に戻ります。(`OpReturn`)
7. 翻訳済み関数(1)：  
   翻訳結果最初の 0 番地の`翻訳済み関数`の逆アセンブル表示です。
   1. 0〜2 番地：  
      入力`a`と`b`をスタックに積みます。(`OpGetLocal`)
   2. 4 番地：  
      `翻訳済み関数(0)`と上記２つの自由変数を持つクロージャを作成し、スタックに積みます。(`OpClosure`)
   3. 8 番地：  
      呼び元に戻ります。(`OpReturn`)

### 再帰呼び出し

関数`countDown`は、関数定義内で、自身を呼び出します。(再帰呼び出し)。  
`1をcountDownする。`と、`場合文`の`それ以外`で`1`から`1`が引かれ、`0`で`countDown`が実行されることにより、さらに、`場合文`で、`0を返す`が実行され、結果`0`になります。

```
>> countDownは、関数【入力がx。xが0に等しい場合【0を返す】、それ以外は【xから1を引き、countDownを実行する】】。１をcountDownする。
翻訳結果：
0000 OpClosure 3, 0	: 翻訳済み関数であって、【入力が、1個。本体が、04 00 06 01 00 00 00 18 31 14 00 19 00 00 01 16 13 00 30 04 00 06 07 00 00 02 18 26 22 15 17】(翻訳済み関数)
0004 OpSetGlobal 0	: countDown(識別子名)
0007 OpConstant 4	: 1を(句)
0010 OpGetGlobal 0	: countDown(識別子名)
0013 OpCall

翻訳済み関数(3)：
0000 OpGetLocal 0	: ??(識別子名)
0002 OpPhrase 1		: が(格)
0004 OpConstant 0	: 0に(句)
0007 OpPredicate 31	: 等しい
0009 OpJumpNotTruthy 19
0012 OpConstant 1	: 0(数値)
0015 OpReturnValue
0016 OpJump 30
0019 OpGetLocal 0	: ??(識別子名)
0021 OpPhrase 7		: から(格)
0023 OpConstant 2	: 1を(句)
0026 OpPredicate 26	: 引く
0028 OpCurrentClosure
0029 OpCall
0030 OpReturn

実行結果: 0
入力: (0)
>>
```

1. 0〜4 番地：  
   `翻訳済み関数(3)`を含む`クロージャ`を、識別子`countDown`に設定します。(`OpClosure`、`OpSetGlobal`)
2. 7〜13 番地：  
   句`1を`を定数表から取り出し(`OpConstant`)、識別子`countDown`から`クロージャ`を取り出し実行します。(`OpGetGlobal`、`OpCall`)
3. 翻訳済み関数(3)：  
    上記 0 番地の`翻訳済み関数`の逆アセンブル表示です。
   1. 0〜2 番地：  
      入力`x`を取り出し、格`が`と合わせ`句`を作ります。(`OpGetLocal`、`OpPhrase`)
   2. 4〜7 番地：  
      句`0と`をスタックに積み(`OpConstant`)、等しいかどうか判定します(`OpPredicate`)。
   3. 9 番地：  
      判定の結果、`真`である場合、次を実行し、`偽`の場合、19 番地に分岐します。(`OpJumpNotTruthy`)
   4. 12〜15 番地：  
      `0`を返し、30 番地に分岐します。(`OpConstant`、`OpReturnValue`、`OpJump`)
   5. 19〜26 番地：  
      入力`x`を取得し、1 を引きます。(`OpGetLocal`、`OpPhrase`、`OpConstant`、`OpPredicate`)
   6. 28〜29 番地：  
      自身(`クロージャ`)をスタックに積み(`OpCurrentClosure`)、実行します(`OpCall`)。
   7. 30 番地：  
      呼び元に戻ります。(`OpReturn`)

-以上-
