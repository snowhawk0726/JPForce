# 文法

日本語ふぉーす(JpForce)の文法を、形式(構文形式)と例(サンプル)を中心に説明します。  
文中の用語には、参考として、対応するプログラミング用語等の英単語をかっこ内に表記しています。  
また、使用例(サンプルコード)には、実行・評価結果や、内容を説明するコメント(ふぉーすコメント形式)を付記しています。

## プログラムの構成要素

### 文(Statement)

文は、述語とその他の要素から成り立っており、プログラムを構成する基本単位です。  
文には構成要素として、予約語、助詞、識別子、数値、記号が含まれます。  
プログラムは、この構成要素を順に解釈し評価することにより、実行されます。  
ふぉーすでは、文の終わりを、句点`。`、改行`\n`、ブロックの終わり`】`、ファイルの終わり`EOF`で判断します。

注：  
当文書では、動詞、形容詞など、日本語文で述語となるものを`述語`と呼んでいます。  
`述語`には、内部で定義・使用される[`予約語`](#予約語keyword)と、プログラムで定義・使用できる[`識別子`](#識別子identifier)があります。  
(日本語文法上は述語ではない`利用可能`、`初期化`なども含みます。)

### 式(Expression)

式は、文中で述語とその引数(目的語や補語等)を演算して値を出力するものを言い、文を構成します。  
(ふぉーすでは、C言語などの既存のプログラミング言語で一般的な、記号を用いた式（例: a = b * 2）は扱っていません。)  
出力する値により、数値 → 算術式、文字列 → 文字式、真偽値 → 条件式または論理式、などと呼んでいます。

_式の例：_

```
aがbより大きい。(真偽値を出力 → 条件式)
１と２を足す。(数値(３)を出力 → 算術式)
「あ」と「い」を足す。(文字列「あい」を出力 → 文字式)
```

注： 上記はいずれも複数の式から成り立っています。ふぉーすにおいて、引数`aが`や述語`大きい`等が１つの式となります。

### 値(Literal)とオブジェクト(Object)

プログラムに書かれる１や「いろは」などの値を表現する書式を **リテラル(literal)** と言います。  
リテラルは、コンピュータ内で解析・評価されて **オブジェクト(object)** というデータとして扱われます。このオブジェクトは、その振る舞いを決める型を持ちます。

値には、単純な値を表す、`数値`、`文字列`、`真偽値`、`無`、集合を表す、`配列`、`辞書`、`列挙`、また、処理を表す`関数`、`算出`、そして定義可能な型を表す`型`などがあります。  

これらは、定義文により、識別子に関連付けることが可能です。  
ふぉーすでは、定義された識別子とオブジェクトの辞書を持ち、これを用いてプログラムを実行します。

また、オブジェクトに対しては、以下のような**属性の取得**および**判定**をすることが可能です。

```
形式：<オブジェクト>の型 (オブジェクトの型を文字列で返す)
形式：<オブジェクト>の数値 (オブジェクトの値を数値で返す)
形式：<オブジェクト>の文字列 (オブジェクトの値を文字列で返す)
形式：<オブジェクト>の名前 (オブジェクトの識別子名を文字列で返す)
形式：<オブジェクト>の数 (オブジェクトの要素数を数値で返す)
形式：<オブジェクト>が空 (オブジェクトの要素が空であるか判定する)
形式：<オブジェクト>が真(または偽) (オブジェクトの真偽を判定する)
形式：<オブジェクト>が無 (オブジェクトが無の場合、真を返す)
形式：<オブジェクト１>(が)<オブジェクト２>(に)等しい。(値が等しい場合、真を返す)
```

オブジェクトの**属性**を得る場合には、<オブジェクト>`の`<属性を表す語>の様に助詞`の`を用い、  
オブジェクトの**評価・判定**を行う場合には、<オブジェクト>`が`<判定語>の様に助詞`が`を用います。

_オブジェクトに対する属性・判定語の使用例：_

```
(1) 「こんにちは」の型。(「文字列」)
(2) aは1。aの型。(「数値」)
    aの文字列。(無)
    bは、配列【1, 2, 3】。bの数。(3)
    bが空。(偽)
    aがbに等しくない。(真)
```

### 予約語(Keyword)

予約語には、以下があります。

1. 主に定義文で使用する「`配列`、`辞書`、`列挙`、`範囲`、`関数`、`型`、`規約`、`算出`」
1. 値(literal)として使用する「`真`、`偽`、`無`」
1. 制御文で使用する「`場合`、`反復`、`間`」
1. 述語(名詞、動詞、形容詞）として使用する「`足す`、`引く`、`掛ける`、`割る`、`等しい`、`小さい`、`大きい`、`ある`、`ない`、`返す`、`返る`、`実行`、`する`、`追加`、`削除`、`繰り返す`、`中止`、`継続`、`写像`、`まとめる`、`絞り込む`、`並び替える`、`含む`、`積む`、`捨てる`、`得る`、`写す`、`代入`、`入れ替える`、`表示`、`改行`、`読む`、`生成`、`設定`、`逆順`、`利用可能`、`初期化`」
1. その他(名詞等)「`正`、`負`、`入力`、`空`、`かつ`、`または`、`および`、`もの`、`こと`、`か`、`よって`、`ファイル`、`ファイル一覧`、`識別子`、`識別子一覧`、`位置`、`キー`、`要素`、`外部`」

### 助詞(Particle)

助詞（以下）は、文の中で区切り文字として扱います。

「`は`、`が`、`を`、`に`、`で`、`と`、`へ`、`から`、`より`、`まで`、`の`、`だ`、`た`、`とは`、`では`」

助詞は、引数として値と共に述語に渡され、述語側で妥当性をチェックすることが可能です。([句](<#句(Phrase)>)を参照)

_助詞の例：_

```
(1) 100から10を引く。(90)
(2) 10を100から引く。(90)
```

助詞`から`と助詞`を`を、述語側でチェックしているため、どちらの語順でも90という結果になります。

#### 特殊な助詞

また、特殊な助詞として、個数を表す`個`も同様に助詞として扱います。([数値の単位](#数値の単位)参照)  
さらに、範囲、比較を表す`以上`、`以下`、`未満`も助詞として扱います。([範囲](#範囲range)、[数値の比較](#数値の比較演算判定)参照)

### 識別子(Identifier)

定義する語(述語等)を表現します。

識別子は、文字、数字、記号を含む語で表し、名詞、動詞、形容詞として使用します。

識別子に使用する語として、

1. 助詞を含む語
1. 記号(注)を含む語
1. 数値で始まる語
1. 予約語「する」「し」「こと」「また」「場合」で終わる語

は使えません。

ただし、`『』`(二重かぎ括弧)で囲うことにより、明示的に識別子として使用することができます。  
(注：ここで言う記号は、[以下にある記号](#記号symbol)です。それ以外の記号は識別子として使用可能です。)  

また、「値」や「文字列」の様な[属性を表す語](#値literalとオブジェクトobject)と同じ識別子を使用することが可能です。  
その場合でも「**〜の<属性を表す語>**」では、識別子より属性の取得が優先され、属性を得ることができます。

_識別子の例：_

```
(1) aは1。aを表示。(1)
(2)『割った余り』は、算出であって、入力がa「数値」とb「数値」であり、本体が、aをbで割り、bを掛け、aから引いたものを返す。
「19を４で割った余りは、\改行なし」と、19を4で『割った余り』を表示する。(19を４で割った余りは、3)
(3) 文字列は-１。文字列の型と文字列の文字列の型を表示する。(数値 文字列)
```

(3)では、識別子「文字列」に数値「-1」を定義していますが、`文字列の文字列`は、前者は識別子、後者は属性取得が優先され、文字列「-1」になります。
このため、`文字列の型`は`数値`、`文字列の文字列の型`は`文字列`になります。

注：『割った余り』は、助詞`た`を含むため、明示的に`『』`で識別子とする必要があります。

### 記号(Symbol)

プログラムを記述するために使用する記号は以下のとおりです。半角文字と同じ全角文字は使用可能です。
(これら以外は、基本的に識別子として使用可能です。)

- ブロック(`【】`)  
  墨付き括弧`【】`で括られた複数の文を、制御文や、関数等の定義において、ひとまとまりの「ブロック」として扱います。  
  ブロックの始まり`【`から終わり`】`までを行末までの一行で記述できる場合、`【】`は省略できます。
- 句読点( `、` `。`)  
  句点`。`は、文の終わりに記述します。句点の後は、新たな文として解釈されます。行末やブロックの前の句点は基本省略可能です。
  読点`、`は、文を読みやすい様に、区切る記号です。
- コメント(`※` `()`)  
  コメントは、プログラム内で、意図や使用方法を読み手に伝えるもので、２通りの記述方法が可能です。
  1.  `（`(丸括弧)で始まり、`）`(丸括弧閉じ)で終わる括弧内をコメントとする。
  1.  `※`(米印)または`*`(アスタリスク)で始まり、行末までをコメントとする。
- タブ(`\t`)、空白(` `)、改行(`\n`)  
  タブや空白は、区切り文字として扱いますが、機能はせず読み飛ばします。プログラムの構造を分かりやすくする様に、使用します。
- 文字列（`「」`)  
  かぎ括弧`「」`で括られた文字列を、プログラム内で識別子に割り当てたり、引数とするための文字列（String Literal)として扱います。
- 識別子（`『』`)  
  二重かぎ括弧`『』`で括られた文字列を、プログラム内で明示的な識別子として扱います。
- エスケープ文字(`\\`)  
  述語`表示`で使用します。文字列中の記号を有効にしたり、表示の制御をしたりするために用います。
- 中黒(`・`)  
  `列挙`で識別子をアクセスするために使用します。([列挙要素のアクセス](#列挙要素のアクセス)を参照)
- 三点リーダ(`…`)  
  関数の入力チェックで、前にある格を持つ引数の数が可変であることを意味します。([入力チェック](#入力チェック)を参照)

### 連用形(語尾変化)

語尾が変化する予約語および識別子(動詞、形容詞)は、連用形での使用が可能です。

連用形は、以下のような語尾および語の辞書を持ち、辞書を使って一致する述語を特定します。これにより、動詞や形容詞の語尾変化に対応しています。

1. 語尾の辞書(連用形 → 終止形)  
   “い”→”う”, "え”→”える", "き”→”く", "ぎ”→”ぐ", "く”→”い", "け”→”ける", "し”→”す", "せ”→”せる", "ち”→”つ", "っ”→”る", "て”→”てる", "に”→”ぬ", "ね”→”ねる", "び”→”ぶ", "み”→”む", "り”→”る", "れ”→”れる", "ん”→”む"
1. 語の辞書(連用形 → 終止形)  
   "し”→”する", "て”→”た", "で”→”だ", "得”→”得る", "見”→”見る", "引い”→”引く",
1. 語の辞書(未然形 → 終止形)  
   "含ま”→”含む"

注： 辞書には、連用形だけでなく未然形の語尾も含みます。これは、述語`ない`が未然形に付くため、その対応です。

_連用形の例：_

```
100は10より大きく、かつ、10は100より小さい。(真)
2と3を足し、10から引く。(5)
```

`大きく`は、`大きい`、`足し`は`足す`の連用形になります。

### スタックによる引数渡し

式の評価結果として生成されたオブジェクトは、スタックに格納されます。述語は、これらのオブジェクトを引数としてスタックから取り出し、処理を行った結果を、再度スタックに出力します。  
このように、複数の式を続けて記述することにより、スタックを介して連続したデータ処理を簡潔に表現できます。

_例：_

```
10と2を掛け、15で割り、2を掛け、-10を足す。(-8)
```

例の様に、`掛ける`、`割る`、`足す`を使った式を続けて記述することで、スタックを介して連続したデータ処理が可能です。

### 句(Phrase)

文中の値や識別子と助詞(注)を組み合わせたものを、「句」と呼び、オブジェクトとして扱います。句は、引数として関数等に渡されます。また、句の中の助詞を「格」と呼びます。  
関数等に渡された引数は、関数内で句から値を取り出したものを入力識別子に代入するため、通常は、句から格を取り出すことはできません。(詳細は[`関数`](#関数function)を参照)

ただし、述語`得る`を使うことにより、スタックにある句から、値や格を直接取り出すことは可能です。(詳細は[`積む`(Push)と`得る`(Pull)と`写す`(Duplicate)](#積むpushと得るpullと写すduplicate)を参照)  
この場合、以下のように、値や格を取り出すことができます。

```
形式：<句>の値 (値を取り出す)
形式：<句>の格 (格を取り出す)
```

句以外のオブジェクトに対して、これらを適用した場合、「<オブジェクト>の値」はオブジェクトそのものが返り、「オブジェクト>の格」は`無`が返ります。  

また、句は、オブジェクトなので、[オブジェクトに対する属性の取得や判定](#値literalとオブジェクトobject)が使用可能です。

### 識別子の有効範囲(Scope)

識別子は、紐づけられたオブジェクトと共に辞書に登録されます。  
この辞書は、通常の(グローバルな)ものとは別に、`型`(および、そのインスタンス)、`列挙`、`関数`、`算出`ごとに個別に（ローカルに）存在します。  
辞書は、それぞれ範囲内で有効であり、識別子は、その範囲内でユニークなものとなります。

有効範囲内では、同一の識別子に値を代入したり、定義をしたりすることはできますが、同じ識別子に代入・定義した場合は、既存の定義や値は上書きされます。

ただし、有効範囲外であっても、呼び出された関数や、生成されたインスタンスから、呼び元（呼び出し元、または同じインスタンス内)の識別子を参照することは可能です。  
さらに、[述語`代入`](#代入assign) または、[代入文](#代入文assignment-statement---要素への代入設定)を使うことにより、呼び元の識別子が持つ値を変更することができます。  

この場合、呼び元の識別子と同じ名前の識別子を、関数等で定義した場合、当該識別子はローカルの辞書に登録され、以降、同識別子は、ローカル辞書を参照します。  

強制的に外部の識別子を参照する場合は、予約語`外部`を使用します。([外部](#外部outer)参照)

## 値(Literal)と型(Type)

ふぉーすでは、オブジェクトの型として、`数値`,`文字列`,`真偽値`,`無`,`配列`,`辞書`,`範囲`,`列挙`,`関数`,`型`,`規約`,`算出`があります。
`数値`,`文字列`,`真偽値`,`無`以外の型では、以下の様な形式で定義することが可能です。

```
形式１：<型名>であって、<型の定義>
形式２：<型名>であり、<型の定義>
形式３：<型名>で、<型の定義>
形式４：<型名>、【<型の定義>】
形式５：<型名>【<型の定義>】
```

形式１から形式３(ブロック記号`【】`無し)は、一行(行末まで)で定義が完了する場合に限ります。  
以降の個々の型の説明では、形式２から形式４のバリエーションはについて、構文形式の記載を省略します。

なお、`関数`および`算出`については[関数](#関数function)を、`型`および`規約`については[型および規約](#型typeと規約protocol)を、  
それぞれ参照してください。

### 数値(Number)

整数(`0`から`9`および`ー`(マイナス)）を数値として扱います。全角半角は区別しません。

#### 数値の単位

数値に続く文字列は、理解を助けるための数値の単位として記述できます。この単位は、解析時に無視されるため、<数値><単位>は、単に<数値>という記述と同じになります。

_例：_

```
鳥は2羽。犬は1匹。鳥と犬を表示する。(2と1が数値として表示される。)
配列【１、２、３】の１番目。(2)
```

ただし、`個`は単位ではなく「助詞」であり、無視されずに述語に`10個`の様に渡されます。  
例えば、3 個の要素`3`をもつ配列を作る場合、以下の様に助詞`個`を使用します。([配列](#配列の要素定義初期化)参照)

_例：_

```
甲は、配列【要素が、３個の３】。甲。(配列であって、【要素が、3と、3と、3】)
```

#### 数値の算術演算

数値を算術演算する(数値を返す)述語には以下があります。

- `足す`(Add)
- `掛ける`(Multiply)  
  述語`足す`と`掛ける`は、２つ以上の数値のオブジェクトをそれぞれ、加算、乗算します。２つは、同じ構文形式です。

```
形式１：<数値１>(と)<数値２>(を)足す(または掛ける)。
形式２：<数値１>と<数値２>と<数値３>…(を)足す(または掛ける)。
```

注：形式２の場合、<数値１>、<数値２>に続く助詞は`と`が必須で、それ以外の助詞では、足す(掛ける)ことができません。形式１の２つの助詞、および、形式２の最後の助詞は任意です。

_例：_

```
1と2を足す。(3)
2に3を掛ける。(6)
3に4を掛け、5を足す。(17)
1と2と3を掛ける。(6)
1に2と3を掛けたものを足す。(7)
```

最後の例では、1 の助詞が、`と`ではなく`に`であるため、1 と 2 は掛けられません。

- `引く`(Subtract)  
  `引く`は、助詞`から`の句の数値から、助詞`を`の句の数値を引きます。

```
形式１：<数値１>(から)<数値２>を引く。
形式２：<数値１>(を)<数値２>から引く。
```

オブジェクトが助詞を持つ句でなくても、引く数値、引かれる数値を判断し、演算します。

_例：_

```
(1) 5から3を引く。(2)
(2) 1と2を足し、5から引く。(2)
(3) 5から、1と2を足したものを引く。(2)
```

(3)では、まず、５をスタックに格納し、さらに１と２を足した結果(3)をスタックに格納します。そして「引く」で、２つをスタックから取り出し、引きます。

- `割る`(Divide)

```　　
形式１：<数値１>(を)<数値２>で割る。
形式２：<数値１>(で)<数値２>を割る。
```

_例：_

```
５を３で割る。(1)
５で、1と9を足したものを割る。(2)
```

- `負数`(Negate)  
  引数の数値の符号を反転し(-1 を掛ける)、値を返します。

```
形式１：<数値>を負数にする。
形式２：<数値>の負数。
```

_例：_

```
10を負数にする。(-10)
aは-1。aの負数。(1)
```

#### 数値の比較演算/判定

- 比較演算  
  数値を比較する(真偽値を返す)述語には以下の様なものがあります。

```
形式：<数値１>(が)<数値２>(より)小さい。
形式：<数値１>(が)<数値２>(より)大きい。
形式：<数値１>(が)<数値２>以上である。
形式：<数値１>(が)<数値２>以下である。
形式：<数値１>(が)<数値２>未満である。
形式：<数値１>(が)<数値２>(に)等しい。
```

かっこで囲われている助詞は種類、有無を問いません。  
`以上`、`以下`、`未満`で比較する場合、上記の通り、肯定`である`、または否定`でない`を付ける必要があります。

_例：_

```
1は2より小さい。(真)
1が1以上である。(真)
1は1未満である。(偽)
1が2に等しくない。(真)
1は1以下でない。(偽)
```

- 数値の判定  
  述語`正`(positive),`負`(negative)は、数値の正負を判定します。

```
形式：<数値>が正(または負)。
```

_例：_

```
xは-1。xが負。(真)
0が正、または、0が負。(偽：0は正でも負でもない)
```

#### 数値の文字化(Cast)

数値を半角の文字列に変換します。

```
形式：<数値>の文字列。
```

_例：_

```
１５の文字列。(「15」)
xは-1。xの文字列。(「-1」)
```

### 文字列（String)

かぎ括弧`「」`で括られた文字列を、プログラム内で文字列として扱います。

#### 文字列の操作/判定

文字列を操作する述語には以下があります。

- `数`(Count)

```
形式：<文字列>の数。(文字数を数値を返す)
```

_例：_

```
「あいう」の数。(3)
```

- `空`(Empty)

```
形式：<文字列>が空。(文字列が空(から)の場合、真を返す)
```

_例：_

```
aは「」。aが空。(真)
```

- `含む`(Contains)

```
形式：<文字列１>が<文字列２>を含む。(含む場合、真を返す)
```

_例：_

```
「かきくけこ」が「く」を含む。(真)
「なにぬねの」が「くけ」を含まない。(真)
```

- `足す`(Add)  
  ２つ以上の文字列を結合します。

```
形式１：<文字列１>(と)<文字列２>(を)足す。
形式２：<文字列１>と<文字列２>と<文字列３>…(を)足す。
```

注：形式２で、複数の文字列を結合する場合、助詞が`と`である必要があります。それ以外の助詞は任意です。

_例：_

```
「あ」と「い」と「う」を足す。(「あいう」)
```

- `逆順にする`(Reverse)

```
形式：<文字列>を逆順にする。(<文字列>の語順を逆にした文字列を返す)
```

_例：_

```
「あいうえお」を逆順にする。(「おえういあ」)
```

#### 文字列の位置/範囲

文字列の位置や範囲を指定する述語には以下があります。

```
形式：<文字列>の<数値(位置)>。(文字列の指定位置にある文字を返す)
形式：<文字列>の先頭/最初。(文字列の先頭にある文字を返す)
形式：<文字列>の後尾/最後。(文字列の後尾にある文字を返す)
形式：<文字列>の残り。(先頭文字以外の文字列を返す)
形式：<文字列>の<範囲>。(指定範囲にある文字列を返す)
```

位置は、数値で、０から始まります。また、指定位置に文字が存在しない場合は、`無`が返ります。

_例：_

```
「あいうえお」の２番目。(「う」)
nは1。「あいうえお」のn(番目)。(「い」)
「あいうえお」の先頭。(「あ」)
「あいうえお」の後尾。(「お」)
「あいうえお」の残り。(「いうえお」)
「あいうえお」の範囲【1から3まで】。(「いうえ」)
「」の最初。(無)
```

#### 文字列の数値化(Cast)

文字列を数値に変換します。数値に変換できない場合は`無`を返します。

```
形式：<文字列>の数値。
```

_例：_

```
「−１」の数値。(-1)
xは真。xの数値。(無)
```

### 真偽値(Boolean)

値を`真`または`偽`で表し、条件式や論理演算の結果となります。

#### 真偽値の論理演算

論理演算の述語には以下があります。

- `ある`(Be)/`ない`(Not)  
  直前の論理式を肯定/否定します。

```
形式：<論理式>ある(<論理式>の結果を真偽値で返す)
形式：<論理式>ない(<論理式>の否定を真偽値で返す)
```

_例：_

```
文字列は「」。文字列が空である。(真)
1は2より小さくない。(偽)　
```

また、２つのオブジェクトが等しいか否かを判定するには、以下の形式で記述します。

```
形式： <オブジェクト１>が<オブジェクト２>である
形式： <オブジェクト１>は<オブジェクト２>である
形式： <オブジェクト１>が<オブジェクト２>でない
形式： <オブジェクト１>は<オブジェクト２>でない
形式： <オブジェクト１>が<オブジェクト２>ではない
形式： <オブジェクト１>は<オブジェクト２>ではない
形式： <オブジェクト１>(が)<オブジェクト２>(に)等しい
形式： <オブジェクト１>(が)<オブジェクト２>(に)等しくない
```

(注：述語`等しい`は引数の助詞を問いません。)

_例：_

```
1は2である。(偽)
1が2ではない。(真)
配列【１、２、３、４、５】は、配列【1,2,3,4,5】に等しくない。(偽)　
```

#### 真偽値の文字化(Cast)

真偽値を文字列に変換します。

```
形式：<真偽値>の文字列。
```

_例：_

```
真の文字列。(「真」)
１と２は等しいの文字列。(「偽」)
```

### 無(Null)

予約語`無`は、値が無いことを示します。

_例：_

```
ハッシュ表は、配列【22, 1, 無, 無, 15, 無, 無, 無, 8, 無, 無】。ハッシュ表の最後。(無)
ハッシュ表の１０番目。(無。配列に１０番目の要素が無い。)
無は真である。(偽)
無は無である。(真)
無の文字列。(「無」)
```

[真偽値の論理演算](#真偽値の論理演算)にある述語`ある`と`ない`により、値があるか無いかを判定する以下の様な記述が可能です。

```
値は１。値がある場合、値を表示する。(1を表示)
値は無。値がある場合、値を表示する。(何も表示しない。)
値がない場合、「🈚️」を表示する。(🈚️を表示)
```

### 配列(Array)

順序を持った値の集合です。

```
形式１：配列【(要素が、)<(複数の)値>】
形式２：配列であって、(要素が、)<(複数の)値>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。  
また、値が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
各要素の型は問いません。

注：各値は、数値などのリテラル、および、オブジェクトを返す式(例： `1と２を足す`)で記述可能です。

_例：_

```
配列【6, 15, 4, 2, 8, 5, 11, 9, 7, 13】をクイックソートし、表示する。
※ 関数「クイックソート」で引数の配列をクイックソートし、コンソールに表示する

甲は、配列であって、要素が、１と、２に２を掛けたものと、３に３を足したもの。(甲は配列【1, 4, 6】)
```

#### 配列要素のアクセス

配列の要素を位置で索引する方法は、以下のとおりです。

```
形式：<配列>の<数値(位置)>。(配列の指定位置にある文字を返す)
形式：<配列>の先頭/最初。(配列の先頭にある文字を返す)
形式：<配列>の後尾/最後。(配列の後尾にある文字を返す)
形式：<配列>の残り。(配列の先頭要素以外の配列を返す)
形式：<配列>の<範囲>。(配列の指定範囲にある配列を返す)
```

位置は、数値で、０から始まります。また、指定位置に要素が存在しない場合は、`無`が返ります。

_配列要素のアクセスの例：_

```
配列【1,3,5,7】の1。(3)
数列は、配列【1, 4, 6】。数列の2番目。(6)
pは4番目。配列【1,3,5,7】のp。(無 →４番目に文字が無い)
配列【1,3,5,7】の先頭。(1)
配列【1,3,5,7】の残り。(配列【3,5,7】)
配列【1,3,5,7,9】の範囲【1から3まで】。(配列【3,5,7】)
配列【】の最初。(無)
```

また、述語`追加`(append)によって、配列に要素を付け加えることができます。

```
形式１：<配列>(に)<値>を追加する。
形式２：<値>(を)<配列>に追加する。
```

_`追加`の例：_

```
配列【１、２、３】に４を追加する。(配列【１、２、３、４】)
配列【１、２、３】に配列【４】を追加する。(配列【１、２、３、配列【４】】)
１と３を足し、配列【１、２、３】に追加する。(配列【１、２、３、４】)
```

さらに、述語`削除`(remove)によって、配列の指定位置にある要素を削除することが可能です。

```
形式：<配列>(から)<数値(位置)>を削除する。(配列の指定位置の要素を削除し、結果を返す）
形式：<配列>(から)「先頭」を削除する。(配列の先頭位置の要素を削除し、結果を返す）
形式：<配列>(から)「後尾」を削除する。(配列の後尾位置の要素を削除し、結果を返す）
形式：<配列>(から)「全て」を削除する。(配列の全ての要素を削除し、結果を返す）
```

_`削除`の例：_

```
配列【1, 2, 3】から、1番目を削除する。(配列【１、３】)
配列【1, 2, 3】から「先頭」を削除する。(配列【２、３】)
配列【1, 2, 3】から「全て」を削除したものの数。(0)
```

さらに、述語`代入`(assign)によって、配列の指定位置に指定オブジェクトを代入することが可能です。  
配列内の位置を指定するには、予約語`位置`を用い、直後に数値または数値オブジェクトを指定します。

```
形式１：<配列>の位置<数値>に<値>を代入する
形式２：<配列>の位置『<識別子>』に<値>を代入する
形式３：<値>を<配列>の位置<数値>に代入する
形式４：<値>を<配列>の位置『<識別子>』に代入する
```

`代入`により、指定位置に<値>が代入された配列オブジェクトが返ります。  
<配列>として<識別子>を指定した場合は、上記配列オブジェクトが<識別子>に上書きされます。

注１：指定位置が数値でない、または配列外の場合、「エラー：指定位置が、配列内に無い。位置：x」になります。  
注２：位置に<識別子>を指定する場合、<識別子>からオブジェクトを取り出すために、二重かぎ括弧`『』`で囲います。かぎ括弧`「」`で囲うと文字列として扱われるため、エラーになります。  
注３：後述の[代入文](#代入文assignment-statement---要素への代入設定)を使うことで、同様の結果が得られます。

_`代入`の例：_

```
配列【１、２、３】の位置１に５を代入する。(配列【１、５、３】)
甲は、配列【１、２、３】。乙は０。甲の位置『乙』に５を代入する。(甲は配列【５、２、３】)
```
２番目の例では、識別子「乙」が０であるため、指定により位置は０となり、甲は代入結果の配列で上書きされます。

#### 配列の操作/判定

文字列と同様に、以下の様な配列を操作/判定する予約語があります。

```
形式：<配列１>(と)<配列２>(と<配列３>)を足す。
形式：<配列>を逆順にする。(配列の要素を逆順にした配列を返す)
形式：<配列>の数。(配列の要素数を数値で返す)
形式：<配列>が空。(配列が空(から)の場合、真を返す)
形式：<配列>が<値>を含む。(配列の要素にオブジェクトが含まれる場合、真を返す)
形式：<配列>が<範囲>を含む。(配列に範囲が含まれる要素(数値)がある場合、真を返す)
```

_例：_

```
配列【1,2,3】と配列【4,5,6】を足す。(配列【1,2,3,4,5,6】)
配列【1,2,3,4,5,6】を逆順にする。(配列【6,5,4,3,2,1】)
行列は、配列【1】。行列の数。(1)
行列が空。(偽)
配列【１、２、３、４、５】が3を含む。(真)
配列【１、２、３、４、５】が配列【１、３】を含む。(偽)
配列【１、２、３、４、配列【１、３】】が配列【１、３】を含む。(真)
配列【１、２、３、４、５】が範囲【６以上】を含む。(偽。６以上の要素が無い)
配列【範囲【１以上５未満】、範囲【６以上１０以下】、範囲【１１以上】】が５を含む。(偽)
```

#### 配列の要素定義(初期化)

空の配列を識別子に割り当てる場合、以下の様に記述可能です。

```
形式１：<識別子>は、配列【】
形式２：<識別子>は、配列であって、【】
形式３：<識別子>は、配列。
```

形式３の場合、句点「。」は必須です。

_例：_

```
行列は、配列。(行列は、配列【】と同じ。)
行列が空。(真)
```

また、以下の様に同一の要素を指定数個持った配列を定義することができます。

```
形式１：配列【(要素が、)<数値>個の<オブジェクト>】
形式２：配列であって、(要素が、)<数値>個の<オブジェクト>
```

_例：_

```
甲は、配列であって、要素が、３個の３。(甲は配列【3,3,3】と同じ。)
```

### 辞書(Dictionary)

要素(キーと値の組)の集合です。  
配列と異なり、要素には順序がありません。キーで索引し、値を得ることから辞書と呼びます。  
各キーは、辞書内でユニークな値です。

```
形式１：辞書【(要素が、)<(複数の)要素>】
形式２：辞書であって、(要素が、)<(複数の)要素>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。

要素の形式は、以下のとおりです。

```
形式：<キー>が<値>
```

また、要素が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
各値の型は問いませんが、キーは、`数値`、`文字列`、`真偽値`のいずれかになります。

注：キーおよび値は、数値などのリテラル、および、オブジェクトを返す式(例： `1と２を足す`)で記述可能です。

_例：_

```
辞書【「一」が0と1を足す、「二」が10から8を引く、「三」が15を5で割る】
（辞書【要素が、「一」が1と、「二」が2と、「三」が3】と同じ）
```

#### 辞書要素のアクセス

辞書をキーで索引する方法は、以下のとおりです。

```
形式：<辞書>の<キー>(の値)
```

辞書内の<キー>で索引し、値を取り出すことができます。  
<キー>が辞書に存在しない場合は、`無`が返ります。  
(注：「の値」は対象が「句」でないは、単に値をそのまま返します。「の値」は、読みやすい様に必要に応じて付記します。)

_要素アクセスの例：_

```
辞書【要素が、「一」が1と、「二」が2と、「三」が3】の「二」。(2)
漢数字表は、辞書【要素が、「一」が1と、「二」が2と、「三」が3】。漢数字表の「三」の値。(3)
漢数字表の「四」の値。(無)
辞書【真が０、偽が１】の偽の値。(1)
```

また、述語`追加`(append)によって、辞書に要素を付け加える、または要素を更新することができます。
<キー>が既存の場合、そのキーで、値を更新します。

```
形式１：<辞書>(に)<キー>が<値>を追加する。
形式２：<キー>が<値>(を)<辞書>に追加する。
形式３：<辞書１>(に)<辞書２>を追加する。
形式４：<辞書２>(を)<辞書１>に追加する。
```

_`追加`の例：_

```
辞書【「一」が１、「二」が２、「三」が３】に「四」が４を追加。
辞書【「一」が１、「二」が２、「三」が３】に辞書【「四」が４】を追加。
nは１と３を足したもの。「四」がnを辞書【「一」が１、「二」が２、「三」が３】に追加。
※ 結果はいずれも、辞書【「一」が１、「二」が２、「三」が３、「四」が４】
```

_`追加`(更新)の例：_

```
変換表は、辞書【「一」が１、「二」が２、「三」が３、「四」が４】。変換表の「四」の値。(4)
変換表に、「四」が無を追加して代入する。変換表の「四」の値。(無)
```

(注：結果の辞書要素の順は不定です。)

さらに、述語`削除`(remove)によって、辞書の指定位置にある要素を削除することが可能です。

```
形式１：<辞書>(から)<キー>を削除する。(辞書のキーの要素を削除し、結果を返す）
形式２：<キー>を<辞書>から削除する。(辞書の指定位置の要素を削除し、結果を返す）
形式３：<辞書>(から)「全て」を削除する。(配列の全ての要素を削除し、結果を返す）
```

_`削除`の例：_

```
辞書【「その一」が１、「その二」が２、「その三」が３】から、「その二」を削除する。
※ 結果：辞書【「その一」が１、「その三」が３】)
辞書【「その一」が１、「その二」が２、「その三」が３】から、「その２」を削除する。
※ キー「その２」は辞書に無いため、辞書【「その一」が１、「その二」が２、「その三」が３】が返る。
キーは「その一」。キーを辞書【「その一」が１、「その二」が２、「その三」が３】から削除する。
※ 結果：辞書【「その二」が２、「その三」が３】)
辞書【「その一」が１、「その二」が２、「その三」が３】から「全て」を削除したものが空。(真)
```

さらに、述語`代入`(assign)によって、辞書の指定キーに値を代入(更新または追加)することが可能です。(辞書に指定キーがない場合、キーと値が追加されます。)  
辞書のキーを指定するには、予約語`キー`を使います。

```
形式１：<辞書>のキー<キー>に<値>を代入する
形式２：<辞書>のキー『<識別子>』に<値>を代入する
形式３：<値>を<辞書>のキー<キー>に代入する
形式４：<値>を<辞書>のキー『<識別子>』に代入する
```

`代入`により、指定したキーに<値>が代入された辞書オブジェクトが返ります。  
<辞書>として<識別子>を指定した場合は、上記辞書オブジェクトが<識別子>に上書きされます。

注１：キーがハッシュ化可能な型（`数値`、`文字列`、`真偽値`）以外の場合、「エラー：キーが、ハッシュ化可能な型ではない。型：x」になります。  
注２：キーに<識別子>を指定する場合、<識別子>からオブジェクトを取り出すために、二重かぎ括弧`『』`で囲います。  
注３：後述の[代入文](#代入文assignment-statement---要素への代入設定)を使うことで、同様の結果が得られます。

_`代入`の例：_

```
(1) 辞書【1が「一」、2が「二」、3が「三」】のキー2に「弍」を代入する。(辞書【1が「一」、2が「弍」、3が「三」】が返る)
(2) 辞書【1が「一」、2が「二」、3が「三」】のキー4に「四」を代入する。(辞書【1が「一」、2が「弍」、3が「三」、4が「四」】が返る)
(3) 甲は、辞書【「い」が「一」、「ろ」が「二」、「は」が「三」】。甲のキー「は」に「参」を代入する。(甲は辞書【「い」が「一」、「ろ」が「二」、「は」が「参」】)
(4) 甲は、辞書【真が1、偽が0】。甲のキー偽に2を代入する。(甲は辞書【真が1、偽が2】)
(5) 甲は、辞書【1が「一」、2が「二」、3が「三」】。乙は２。関数【「弍」を甲のキー『乙』に代入する。】を実行する。(辞書【1が「一」、2が「弍」、3が「三」】)
```

(1)と(2)は代入する対象がリテラルのため、代入された辞書が返ります。((2)は追加)  
(3)から(5)は代入する対象が識別子のため、代入された結果が識別子に代入されます。

#### 辞書の操作/判定

以下の様な辞書を操作/判定する予約語があります。

```
形式：<辞書１>(と)<辞書２>(が)等しい。(辞書の要素が全て等しい場合、真を返す)
形式：<辞書>の数。(辞書の要素数を数値で返す)
形式：<辞書>が空。(辞書が空(から)の場合、真を返す)
形式：<辞書>が<値>を含む。(辞書の要素にオブジェクトが含まれる場合、真を返す)
```

_例：_

```
辞書【「あ」が１、「い」が２、「う」が3】が辞書【「う」が3、「あ」が１、「い」が２】に等しい。(真)
dictionaryは辞書。dictionaryが空。(真)
```

#### 辞書の要素定義

空の辞書を識別子に割り当てる場合、以下の様に記述可能です。

```
形式１：<識別子>は、辞書であって、【】
形式２：<識別子>は、辞書【】
形式３型：<識別子>は、辞書。
```

形式３の場合、句点「。」は必須です。

### 列挙(Enumeration)

複数の要素(列挙子とその値)の集合です。

```
形式１：列挙【(要素が)、<(複数の)要素>】
形式２：列挙であって、(要素が、)<(複数の)要素>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。  
要素の形式は、以下のとおりです。

```
形式１：<列挙子>は<値>
形式２：<列挙子>
```

<列挙子>は、列挙定義内のユニークな識別子であり、助詞`は`によって、値(オブジェクト)を指定することができます。  
また、形式２のように値を指定しない場合、値は 0 から順に数値が割り当てられます。  
(注：形式１は、[定義文](#定義文define-statement)と同じ形式です。)

要素が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
値として数値を指定し、その後は値を指定しない場合、以降の値は順に、指定値に１を足した数値になります。

_列挙の例：_

```
曜日は、列挙であって、【要素が、
	月は「月曜」、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」。
】。
曜日の火の値。(「火曜」)
列挙【月、火、水、木、金、土、日】の火の値。(1)
列挙【aと、bと、cは10と、d】。(列挙【aは０、bは1、cは10、dは11】と同じ。)
```

#### 列挙要素のアクセス

列挙の要素を参照する方法は、以下の様に３通りあります。

```
形式１：<列挙>の<列挙子>
形式２：<列挙>・<列挙子>
形式３：・<列挙子>
```

形式２と３では、記号`・`(中黒、中点)を使って要素をアクセスします。  
形式３では、<列挙>が辞書に登録されている場合、つまり、定義文で識別子に定義されている場合に使えます。  
いずれも列挙子を持つ要素のオブジェクトが返ります。

さらに、上記の様に得られた要素オブジェクトを、以下の様にアクセスすることができます。

```
形式：<要素>の列挙子(識別子名(文字列)を返す)
形式：<要素>の値(識別子に定義された値を返す)
形式：<要素>の型(要素を含む列挙型名(文字列)を返す)
```

_要素アクセスの例：_

```
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日の型。(「列挙」)
曜日の日の型。(「曜日」)
曜日・火の列挙子。(「火」)
・火の列挙子。(「火」)
・火の値。（「火曜」）
木曜日は、・木。木曜日が、曜日の木に等しい。(真)
列挙【月、火、水、木、金、土、日】の日の型。(「」(空文字を返す)
```

また、述語`代入`(assign)によって、列挙の要素に値を代入したオブジェクトを得ることができます。

```
形式１：<値>を<要素>に代入する。(<値>が代入された<要素オブジェクト>を返す)
形式２：<要素>に<値>を代入する。(<値>が代入された<要素オブジェクト>を返す)
```

注： 列挙オブジェクトの要素(値)を更新することはできません。列挙の要素(識別子と値)は不変です。

_`代入`の例：_

```
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日の木の値。(「木曜」)
木曜日は、・木に「Thursday」を代入したもの。
木曜日の値。(「Thursday」)
曜日の木の値。(「木曜」)
```

この様に、<列挙オブジェクト>である識別子「曜日」の木の値は、代入によって変更されません。

さらに、２つの<要素>が等しいか否かは、述語`等しい`を使います。

```
形式：<要素１>(が)<要素２>に等しい。(２つの要素が等しい場合に真を返す)
```

注：<要素１>の句の助詞は、種類・有無を問わないが、<要素１>が識別子である場合、助詞`は`は使えない。(「<識別子>は〜」の形式は、定義文とみなされるため。)

これまで、列挙子を使った要素の参照を説明しましたが、さらに、述語`生成`(create)を用いて、要素の値から要素を生成(コピー)し、アクセスすることが可能です。

```
形式１：<値>で<列挙>から生成。(生成された要素オブジェクトを返す)
形式２：「<識別子名>」を<値>で<列挙>から生成。(生成された要素オブジェクトを識別子に代入する)
形式３：<列挙>から<値>で「<識別子名>」を生成。(生成された要素オブジェクトを識別子に代入する)
```

形式２と形式３では、指定した識別子名の識別子に生成した要素オブジェクトを代入します。  
注：識別子名は、文字列で指定します。(「」(カギ括弧)が必要。）

_要素生成の例：_

```
曜日は、列挙であって、【
  要素が、
    月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」。
】。
予定日は、「水曜」で曜日から生成したもの。予定日の列挙子。(「水」)
「Monday」を月曜日の値で曜日から生成する。Mondayの列挙子。(「月」)
曜日から「火曜」で「火曜日」を生成する。火曜日の列挙子。(「火」)
```

### 範囲(Range)

「〜以上〜以下」のような数値の範囲を表します。

```
形式１：範囲【<範囲式>】
形式２：範囲であって、<範囲式>
```

<範囲式>は、数値返す式と助詞`から`,`まで`,`以上`,`以下`,`未満`で構成されます。また、組み合わせにより、下限、上限、上下限の３通りを表現できます。  
`から`と`以上`は下限を表し、`まで`と`以下`と`未満`は上限を表します。  
上下限を表す場合は、`から`と`まで`、または、`以上`と`以下`(または`未満`)の組み合わせが可能です。

_範囲の例：_

```
１は範囲【１以上】にある。（真）
範囲【1以上5未満】が5を含む。(偽)
「あいうえお」の範囲【1から3まで】。(「いうえ」）
甲は、範囲であって、10未満。(甲は範囲【10未満】)
```

#### 範囲の判定

数値が`範囲`に属するか否かを判定するには、述語`ある`(be)、`ない`(not)、および`含む`(contains)を使って以下の様に記述します。(いずれも真偽値を返します。)

```
形式１：<数値>が<範囲>にある(ない)
形式２：<数値>は<範囲>にある(ない)
形式３：<範囲>が<数値>を含む
```

注：<数値>が<識別子>である場合、助詞`は`は使えません。(「<識別子>は〜」の形式は、定義文とみなされるため。)

_例：_

```
1が範囲【１以上２以下】にある(真)
11が範囲【１から10まで】にある(偽)
範囲【1以上】が3を含む(真)
範囲【1まで】が3を含む(偽)
```

また、２つの範囲が等しいか否かを判定するには、述語`等しい`を使って以下の様に記述します。

```
形式１： <範囲１>が<範囲２>に等しい
形式２： <範囲１>は<範囲２>に等しい
```

注：<範囲１>が<識別子>である場合、助詞`は`は使えません。(「<識別子>は〜」の形式は、定義文とみなされるため。)

_例：_

```
範囲【1から3まで】が範囲【1以上3以下】に等しい(真)
範囲【1から3まで】は範囲【1以上3未満】に等しい(偽)
```

#### 範囲の数

範囲内の数値の数を数える予約語として、`数`(かず)、`空`(から)があります。

```
形式：<範囲>の数(範囲内の数値の数を返す)
形式：<範囲>が空(範囲内に数値が無い場合に真を返す)
```

注：範囲内の数値を数えることができるのは、範囲式が上下限である場合のみです。それ以外ではエラーメッセージ「「範囲」の上下限が数値でないため、数えることができない。」が返ります。

_例：_

```
範囲【1から3まで】の数(3)
範囲【１以下】の数(エラー：「範囲」の上下限が数値でないため、数えることができない。)
範囲【1から3まで】が空(偽)
範囲【1以上1未満】が空(真)
```

なお、`文字列`(string)、`配列`(array)の範囲を表す「の範囲」については、それぞれ、[文字列の位置/範囲](#文字列の位置範囲)、[配列要素のアクセス](#配列要素のアクセス)を参照してください。  
また、配列が範囲を含むか否かについては、[配列の操作/判定](#配列の操作判定)を参照してください。

## 基本構文

プログラムを作成する上で基本的な構文を以下に示します。  
型に依存する式などの構文は、それぞれの型で説明しています。([値と型](#値literalと型type)参照)。また、型に共通する述語、その他については、後述の[述語](#述語predicate)で説明します。

### 定義文(Define Statement)

定義文は、識別子に定義内容を割り当てます。  
定義された識別子と定義内容は、辞書に登録されます。

```
形式：<識別子>は、<定義内容>。
```

<定義内容>は、オブジェクトを返す式、識別子、リテラルなどです。すなわち、解釈・評価の結果、オブジェクトになる内容を定義する必要があります。  
また、ブロックや、定義文を、定義内容とすることはできません。同じ<識別子>に定義した場合は、再定義(上書き)になります。

_定義文の例：_

```
aは1。(数値１をaに割り当てる。)
bはa。(bにaを割り当てる。→ b=1)
cは、1と2を足したもの。(1と2を足した結果3を、cに割り当てる)
挨拶は、「こんにちは」。(文字列「こんにちは」を、識別子「挨拶」に割り当てる。)
加算は、関数であって、入力がaとbで、aとbを足し、返す。(引数aとbを足して返す関数を、識別子「加算」に割り当てる。)
```

_定義文にできない定義内容の例：_

```
aは、bは１。(エラー。定義文は定義内容にできない。)
aは、【1と2を足す】。(エラー。ブロックは定義内容にできない。)
```

#### 副詞`さらに`による拡張定義(Extension、Function Overloading)

副詞`さらに`を使うことにより、定義文の定義を拡張することができます。

```
形式：<識別子>は、さらに、<定義内容>。
```

同一の識別子に、定義文で定義をした場合、既存の定義は上書きされますが、`さらに`をつけることにより、<定義内容>は、既存の定義を拡張するもになります。  

拡張できる定義は、後述する[`関数`](#関数の多重定義function-overloading)、[`算出`](#算出の多重定義)、[`型`](#型の拡張type-extension)、[`規約`](#規約の実装定義protocol-extension)です。  
詳細は、リンク先を参照ください。

### 場合文(If-else Statement, Switch-case Statement)

場合文は、条件により実行処理を変えます。場合文には、以下の２つの形式があります。

```
形式１：<条件式>場合、【<真の実行処理>】(、それ以外は、【＜偽の実行処理＞】)。
形式２：<値>が、<値１>の場合、【<実行処理１>】、<値２>の場合、【<実行処理２>】、…、それ以外は、【<それ以外の実行処理>】。
```

注： ブロックの終わり`】`が、行末になる場合は、ブロックを省略可能です。

形式１では、<条件式>が評価された結果が「真」であれば<真のフロー>が実行され、「偽」であれば＜偽の実行処理＞が実行されます。  
「それ以外は、〜」は省略可能であり、その場合、条件式が「偽」であれば、単に<真の実行処理>をスキップします。

_形式１の例：_

```
甲は１。乙は２。甲が１より小さい場合【甲を表示し】、それ以外は、乙を表示する。(2(乙)が表示される。)
aは10。aが範囲【1以上10未満】にある場合、aを表示する。(範囲外のため10(a)は表示されない。)

甲は０。乙は１。
甲が１より小さい場合、甲を表示し、
それ以外は、乙を表示する。
※ 甲が１より小さいので、0が表示される。
```

注：「それ以外」の前(同行)にある<真の実行処理>のブロック`【】`は省略不可です。(省略すると、行末までが、<真の実行処理>になる。)

形式２では、<値>が以降の<値１>、<値２>、…のいずれかに一致した場合に、それぞれに対応した実行処理が実行されます。  
いずれにも一致しない場合は、<それ以外の実行処理>が実行されます。形式２では「それ以外は、〜」は、省略不可です。

_形式２の例:_

```
甲が、1 の場合【「い」を表示し】、2 の場合【「ろ」を表示し】、それ以外は、「ん」を表示する。
```

注：「それ以外」の前(同行)にある<実行処理>のブロックは省略不可です。

_形式２（ブロック省略)の例：_

```
フィボナッチ数は、関数であって、【入力が数字「数値」であり、本体が、
    数字が、
    １の場合、１を返す。
    ２の場合、２を返す。
    それ以外は、【
        数字から１を引き、フィボナッチ数を実行したものと、
        数字から２を引き、フィボナッチ数を実行したものを、
        足し、返す。
    】
】。
1から12まで反復【入力が数字で、数字でフィボナッチ数を実行し、表示する】。
※ 1から１２までのフィボナッチ数が表示される。
```

注：「１の場合」「２の場合」は、行末が、それぞれのブロックの終わりであるため、ブロック記号`【】`を省略しています。

形式２では、さらに、値として、配列または範囲を指定することができます。この場合、最初の<値>が、配列または範囲に属する(含まれる)場合に、それぞれの実行処理が実行されます。

_形式２(配列、範囲との比較)の例:_

```
aが、配列【1,3,5,7,9】の場合、【「奇数」を表示し】、配列【2,4,6,8,10】の場合、【「偶数」を表示し】、それ以外は、「対象外」を表示する。
aが、範囲【1以下】の場合、【aと1を足し】、範囲【2以上4未満】の場合、【aと2を足し】、それ以外は、aと3を足す。
```

さらに、`列挙`との組み合わせで以下の様に箇条書き風に表記できます。

_形式２(列挙との組み合わせ)の例：_

```
曜日は、列挙【月曜、火曜、水曜、木曜、金曜、土曜、日曜】。
今日は、・金曜。
今日が、
・土曜の場合、「土」を表示する。
・日曜の場合、「日」を表示する。
それ以外は、「平日」を表示する。
(「平日」が表示される。)
```

### 反復文(Loop(while, for) Statement)

反復文は、指定した条件等により実行処理を反復します。以下の５つの形式があります。

```
形式１：反復【(条件が、<条件式>の間、)<実行処理>】。
形式２：<数値>から<数値>まで（<数値>ずつ）反復【入力が<識別子(カウント値)>であり、<実行処理>】。
形式３：<範囲>を反復【入力が<識別子(カウント値)>であり、<実行処理>】。
形式４：<配列>を反復【入力が<識別子(値)>であり、<実行処理>】。
形式５：<辞書>を反復【入力が<識別子(キー)>と<識別子(値)>であり、<実行処理>】。
```

注：反復文の入力を示す「入力が」(または「入力は」)部分の終端(文字)には、句点「。」または「で」が必要です。「で、」「であり、」も可能ですが、読点「、」単独では終端になりません。

**形式１**では、<条件式>が真である間、<実行処理>を反復します。(C言語など既存プログラミング言語の while 文に相当)  
反復条件「条件が、<条件式>の間」のチェックは、<実行処理>の前に行われます。  
また、反復条件は省略することが可能ですが、その場合、[述語`中止`](#反復制御述語中止breakと継続continue)で中止しない限り処理を反復します。

_形式１の例：_

```
※ 反復条件を指定
合計は０。数字は１。
反復であって、条件は、数字が１０より小さい間、合計に数字を足して代入。数字に１を足して代入。
合計を表示する。(45)

※ 反復条件を省略
合計は０。数字は１。
反復【
  合計に数字を足して代入。
  数字に１を足して代入。
  数字が９より大きい場合、中止する。
】。
合計を表示する。(45)
```

**形式２**では、指定した数値範囲で、指定した数値(ステップ数)ごと処理を反復します。(C言語の様な既存プログラミング言語の for 文に相当)  
処理の中では、カウント値を利用できます。  
また、数値(ステップ数)は省略可能であり、その場合は、１ずつカウントアップします。さらに、負数を指定した場合は、カウントダウンします。

_形式２(カウントダウン)の例：_

```
数列は「」。
９から１まで−１ずつ反復【入力は数字。数列と、数字の文字列と「 」を足して代入】。
数列を表示する。(9 8 7 6 5 4 3 2 1 )
```

**形式３**では、指定した`範囲`の数値ごとに処理を反復します。処理をしている範囲の数値を、指定した識別子(入力識別子)で利用可能です。入力識別子の指定は省略できません。

_形式３(範囲の反復)の例：_

```
合計は０。
範囲【１以上１０未満】を反復【入力は数字、合計に数字を足して代入】。
合計を表示する。(45)
```

**形式４**では、指定した`配列`の要素で処理を反復します。処理をしている配列の要素を、指定した識別子(入力識別子)で利用可能です。入力識別子の指定は省略できません。

_形式４（配列の反復）の例：_

```
合計は０。
配列【１、２、３、４、５、６、７、８、９】を反復【入力は数字、合計に数字を足して代入】。
合計を表示する。(45)
```

**形式５**では、指定した`辞書`の要素(キーと値)で処理を反復します。処理をしている辞書(キーと値)の要素を、指定した識別子(入力識別子)で利用可能です。入力識別子は、２つ指定することが必要です。

_形式５（辞書の反復）の例：_

```
合計は０。
辞書【１が１、２が２、３が３、４が４、５が５、６が６、７が７、８が８、９が９】を反復【入力が索引と値。合計に値を足して代入】。
合計を表示する。(45)
```

注：形式３〜５は、述語`繰り返す`を使うことにより、同じことができます。

#### 反復制御述語`中止`(Break)と`継続`(Continue)

述語`中止`(break)と`継続`(continue)により、反復文の中で、実行処理を制御することができます。

`中止`は、実行処理を中止し、反復文を終了します。  
`継続`は、以降の実行処理をスキップし、反復文を継続します。すなわち、カウント値があれば更新し、次の実行処理を先頭から行います。

注：これらの述語は反復文が二重になっている場合、内側の反復文にのみ作用します。

_`継続`の例：_

```
割り切れるは、算出【入力が左と右。左を右で割り、右を掛け、左から引いたものが０に等しい】。
奇数列は、配列【】。偶数列は、配列【】。
配列【１、２、３】を反復【入力が数。
    数が２で割り切れない場合、【
        奇数列に、数を追加して代入する。
        継続する。
    】
    偶数列に、数を追加して代入する。
】。
偶数列。(配列【2】)
奇数列。(配列【1,3】)
```

例では、1 から 3 まで反復し、２で割り切れなかった場合、奇数列に数を追加して次の処理を行います。割り切れた場合は、偶数列に数を追加し、次の処理を行います。  
２を偶数列に追加後も、`継続`により次の反復処理が行われるため、奇数列には３が追加されます。

_`中止`の例：_

```
割り切れるは、算出【入力が左と右。左を右で割り、右を掛け、左から引いたものが０に等しい】。
『三の倍数』は配列。『その他』は配列。
範囲【1から10まで】を反復【入力が数。
    数が３で割り切れる場合、『三の倍数』に、数を追加して代入し、中止する。
    『その他』に、数を追加して代入する。
】。
『三の倍数』。(配列【3】)
『その他』。(配列【1,2】)
```

例では、１から 10 まで処理を反復しますが、３で割り切れた場合、処理を中止しているため、『三の倍数』には、3 のみが、『その他』には、３より前の 1 と 2 が配列の要素になり、４から 10 までは要素に追加されません。

### 接続詞「かつ(And)」と「または(Or)」の構文

接続詞`かつ`(and)と`または`(or)は、述語と異なる形式の構文を持ちます。

接続詞`かつ`、`または`は、式を続けて記述することができます。  
判定は順次(注)ですが、ブロックで囲うことによって、判定の順序を変更できます。
(注：`かつ`と`または`の優先順位はありません。)

#### 論理積`かつ`(Logical And)

２つの論理式の論理積を返します。

```
形式：<論理式１>、かつ、<論理式２>(真偽値を返す)
```

_論理積の例：_

```
1が2に等しい、かつ、1が1に等しい。(偽)
1が1に等しい、かつ、2が2に等しい、かつ、3が3に等しい。(真)
```

#### 論理和`または`(Logical Or)

２つの論理式の論理和を返します。

```
形式：<論理式１>、または、<論理式２>(真偽値を返す)
```

_論理和の例：_

```
1が2に等しい、または、1が1に等しい。(真)
1が1に等しい、または、2が2に等しい、または、3が3に等しい。(真)
```

_和積混在の論理式の例：_

```
1が1に等しい、または、2が2に等しい、かつ、3が4に等しい。(偽)
1が1に等しい、または、【2が2に等しい、かつ、3が4に等しい。】。(真)
1が2に等しい、かつ、【2が2に等しい、または、3が3に等しい】。(偽)
```

ブロック`【】`がある論理式の判定が優先されます。

#### 選択肢`または`

`または`には、論理和だけでなく、値を選択的に判定するための形式があります。

```
形式：<値１>または<値２>…
```

これは、述語`ある`・`ない`・`等しい`と組み合わせ、以下の様に使用します。

```
形式１：<値>が<値１>または<値２>…である。(真偽値を返す)
形式２：<値>が<値１>または<値２>…に等しい。(真偽値を返す)
形式３：<値>が<値１>または<値２>…でない。(真偽値を返す)
形式４：<値>が<値１>または<値２>…に等しくない。(真偽値を返す)
```

形式１と形式２は同じ意味で、<値>が、<値１>または<値２>…に等しいかを判定します。  
形式３と形式４も同じ意味で、<値>が、<値１>または<値２>…に等しくないかを判定します。  
すなわち、形式３と形式４は、それぞれ、形式１と形式２の否定を意味します。

また、これらは、形式５の様に[場合文](#場合文if-else-statement-switch-case-statement)で用いることで、より簡潔な表現で条件分岐を記載できます。

```
形式５：<値>が、<値１>または<値２>…の場合、
```

さらに、これらは、`配列`を使った以下の形式と同じ意味になります。

```
形式６：<値>が配列【<値１>、<値２>、..】にある。
形式７：<値>が配列【<値１>、<値２>、..】にない。
```

形式６は形式１、２と、形式７は形式３、４と同じ意味です。

_選択肢`または`の例：_

```
1が、1または2に等しい、かつ、2が2に等しい、または、3が3に等しい。(真)
3が範囲【１から2まで】または範囲【４から10まで】にある。(偽)
3が配列【１、２、３】にない。(偽。３が１または２または３でない、と同じ)
```

_場合文での使用例：_

```
曜日が、
・木曜または・日曜の場合、「休診日」と表示。
・土曜の場合、「午後休診」と表示。
それ以外は、「診療日」と表示。
```

### 条件演算式「によって」(Ternary Condtional Operator)

条件が成立した場合と不成立の場合で、それぞれの値を返します。  
`場合文`を使うより、簡潔な記述が可能です。  
既存プログラミング言語では、三項条件演算子(Ternary Condtional Operator)と呼ばれ、`a ? b：c`のように記述します。

```
形式１：<条件>によって、<値１>か<値２>
形式２：<条件>かによって、<値１>か<値２>
```

`場合文`と異なり、処理(ブロック)ではなく式であり、`【】`は不要です。また、<値２>の省略は不可です。  
<条件>の後の`か`の有無は任意です。(`か`は他に作用をしません。)

例：

```
条件は、1が2より小さい。甲は、条件によって10か20。甲。(10)
年齢は17歳。入場者は、年齢が18以上であるかによって、「成人」か「未成年」。入場者。(「未成年」)
```

## 関数(Function)と算出(Computation)

`関数`と`算出`は、共に一連の処理を定義・表現するためのものです。  
これらは、必要に応じて引数から得た入力で処理を行い、結果を返り値として返します。

`関数`や`算出`を、定義文により定義することにより、識別子を新たな述語として定義することができます。

### 関数(Function)

`関数`は、主に入力を得て処理を行い、結果をオブジェクトとして返します。(返されたオブジェクトは、スタックに格納されます。)

```
形式１：関数【(入力が、<入力定義>。)(本体が、)<実行処理>】
形式２：関数であって、(入力が、<入力定義>。)(本体が、)<実行処理>
```

#### 関数の入力定義

<入力定義>は、基本的に識別子を助詞`と`を使い、入力する識別子を必要個並べます。(入力の識別子は、既存プログラミング言語では、仮引数と呼ばれます。)  
入力が無い場合は、入力定義は不要です。

```
形式：入力が、<識別子１>(と<識別子２>と…)。
```

注：「入力が」(または「入力は」)部分の終端(文字)には、句点「。」または「で」が必要です。「で、」「であり、」も可能ですが、読点「、」単独では終端になりません。

複数の引数を入力する場合、渡された引数の順に識別子に代入(入力)されます。たとえば、関数「加算」の入力が識別子`a`と`b`であった場合、`１と２を加算する。`の引数`1と`、`2を`は、`a`に 1、`b`に２がそれぞれ代入されます。(注：入力の際、助詞`と`と`を`は省かれます。)

引数の数が、入力として指定した識別子の数に満たない場合、エラーとなります。

#### 既定値を持つ入力（Default Parameter Values)

`関数`の入力識別子は、以下の形式で既定値を持つことができます。

```
形式：入力が、<識別子１>は<既定値１>(と、<識別子２>は<既定値２>と、…)。
```

既定値を指定した識別子は、関数に渡す引数を省略することが可能です。

ただし、識別子を[可変長(…)に指定](#入力チェック)した場合、既定値を持つことはできません。
(可変長の引数、すなわち、指定の型と格を持つ引数を省略することは可能です。その場合、識別子には空の配列が割り当てられます。)

また、既定値を指定した識別子と、指定していない識別子が混在する場合、既定値を持たない識別子を先に定義してください。(引数は、先頭から割り当てるため、後ろの識別子に正しく値を割り当てることができなくなります。)

注：入力識別子に既定値を指定し、かつ、識別子の<型>を指定した場合、既定値の型と指定<型>が一致しないと、エラーになります。(エラー：既定値の型が指定形式と一致しない。)

_既定値を持つ入力の例：_

```
甲は、関数【入力が、xと、yは1と、zは2。xとyとzを足す】。
(1) 1と2と3で甲を実行。(6)
(2) 1と2で甲を実行。(5)
(3) 1で甲を実行。(4)
```

`x`は既定値が定義されておらず、`y`と`z`は既定値を定義しています。  
(1)では、３つの引数を渡しているので、既定値は無視され、３つの入力識別子に引数が割り当てられます。  
(2)では、２つの引数を渡しているので、残りの`z`は既定値`2`が割り当てられます。  
(3)では、`x`に`1`が割り当てられ、残りは既定値が割り当てられます。

_可変長引数と既定値を持つ入力の例：_

```
挨拶は、関数【入力が、相手１「と…」と、相手２「に」と、呼びかけは「こんにちは」。
    相手１を「」と関数【入力が初期値と値。初期値と値と「、」を足す】でまとめたものと、
    相手２と「、」と、呼びかけと、「。」を足す。
】
(1)「Alice」と「Bob」と「Charlie」に「こんばんは」で挨拶する。(Alice、Bob、Charlie、こんばんは。)
(2)「Alice」と「Bob」に挨拶する。(Alice、Bob、こんにちは。)
(3)「Alice」に「おはよう」で挨拶する。(Alice、おはよう。)
```

`相手１`は格が「と」である可変長識別子、`相手２`は格が「に」である識別子、`呼びかけ`は既定値「こんにちは」を持つ識別子です。これらに引数を渡すことで、(1)〜(3)の様な文字列が返ります。

(1)は、可変長識別子`相手１`に「Alice と」と「Bob と」を、`相手２`に「Charlie に」を、`呼びかけ`には「こんばんは」を渡しています。`呼びかけ`の値は、既定値でなく「こんばんは」になります。  
(2)は、可変長識別子`相手１`に「Alice と」を、`相手２`に「Bob に」を渡し、`呼びかけ`には引数を渡していないため、その値は、既定値「こんにちは」になります。  
(3)は、可変長識別子`相手１`に引数を渡さず、`相手２`に「Alice に」を、`呼びかけ`には「おはよう」を渡しています。`呼びかけ`の値は、既定値でなく「おはよう」になります。

#### 関数の実行（Function Call)

`関数`の<実行処理>を実行するためには、述語`実行`または`する`を用い、関数を実行する(呼び出す)ことが必要です。以下の形式で関数を実行します。

```
形式１：<関数>(を)実行
形式２：<関数>(を)する
形式３：<関数>(を)実行する
```

関数は、実行されるまでは、引数や返り値として使用することができます。
([関数を引数とする例](#関数の使用例)を参照)

#### 述語`返す`と`返る`(Return)

`返す`と`返る`は、主に関数の実行処理を終了し、呼び元の処理に復帰する場合に使用します。

`返す`(return)は、実行処理の結果を返す場合に使います。
返した値は、スタックに格納され、関数等の呼び元から利用することができます。

```
形式１：<値>(を)返す
```

<値>を返し、<実行処理>を終了します。(`返す`に続く文、式等は無効です。)  
返す<値>は必須です。

`返す`を使わずに、暗黙的に返り値をオブジェクトとしてスタックに格納し、その後、別の処理を行うことも可能です。

また、`返る`(return)は、値を返さずに実行処理を終了する場合に使います。

```
形式２：返る
```

#### 関数の使用例

_関数の定義と実行例：_

```
(1) 二倍は、関数【入力がxで、xに2を掛け、返す】。５を二倍し、二倍する。(20)
(2) 加算は、関数【入力がaとbで、aにbを足す】。1に2を加算する。(3)
(3) 5で関数【入力がxで、x】を実行する。(5)
```

(２)と(３)の例では、`返す`を使わずに暗黙的にオブジェクトをスタックに格納し、実行処理を終了しています。

_関数を引数とする例：_

```
適用は、関数【入力がaとbと演算で、aとbを演算する】。
加算は、関数【入力がaとbで、aにbを足す】。10と2に、加算を適用する。(12)
減算は、関数【入力がaとbで、aからbを引く】。10と2に、減算を適用する。(8)
```

関数「適用」は、入力に２つの数値と関数を取り、引数の関数(「加算」「減算」)によって振る舞いを変更しています。

#### 入力チェック

引数の型と格をチェックすることが可能です。チェックするには、入力の識別子にかぎ括弧`「`と`」`を付けて、以下の様に記述します。

```
形式：<識別子>「<型><格>…」
```

かぎ括弧内と識別子の数を合わせて「**シグネチャ**」と呼びます。  
注：<型>、<格>、…で、チェック/指定しないものは省略可能ですが、順番は変更できません。

- <型>  
  引数の型をチェックします。(一致しない場合はエラー)
- <格>  
  引数の格(助詞)をチェックします。(一致しない場合はエラー)
- …(三点リーダ)  
  引数の数をチェックせず、述語`足す`の様に、同じ型と格が続く限り引数を処理します。  
  すなわち、指定した連続する型と格を持つ引数(可変長)の値を配列にし、識別子に渡します。一致する引数が無い場合、空の配列が渡されます。

三点リーダを指定した場合を除き、引数の数もチェックします。引数の数が、指定した識別子の数に満たない場合はエラーになります。

注：関数が多重定義されている場合、上記のチェックによるエラーは検出されません。([関数の多重定義](#関数の多重定義function-overloading)を参照)。  
多重定義にシグネチャが一致する関数が見つからない場合は、`エラー：入力形式が一致する関数が見つからなかった。`が出力されます。

_入力チェックの例:_

```
(1) 加算は、関数【入力がa「数値」とb「数値」で、aにbを足す】。1と2の加算する。(3。型のチェックOK)
(2) 加算は、関数【入力がa「と」とb「を」で、aにbを足す】。1と2を加算する。(3。格のチェックOK)
(3) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。1に2を加算する。(3。型と格のチェックOK)
(4) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。「a」に「b」を加算する。(エラー：入力の型が異なる。入力の型：文字列)
(5) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。1と2を加算する。(エラー：入力の格が異なる。入力の格：と)
(6) 加算は、関数【入力がa「数値と…」とb「数値を」。aをbと関数【入力が初期値と値で、初期値に値を足す】でまとめる】。1と2と3と4と5を加算する。(15)
```

(４)と(５)の例では、引数のシグネチャが異なるためエラーが返っています。  
(６)の例では、述語`まとめる`(reduce)を使い、1 から 5 までの合計を求めています。引数のシグネチャがチェック形式と一致しているので結果が返っています。  
この場合、`a`は、`…`の指定により可変長識別子となり、連続する型`数値`と格`と`を持つ引数`1と2と3と4と`が渡され、その値の配列`配列【1,2,3,4】`が代入されます。`b`には、格`を`を持つ引数`5を`が渡され、`5`が代入されます。

#### 関数の多重定義(Function Overloading)

関数を定義文で定義し、さらに以下の形式で定義することにより、関数を多重定義することができます。  
多重定義には、副詞`さらに`を使用します。

```
形式： <識別子>は、<関数定義１>。
      <識別子>は、さらに、<関数定義２>…
```

これにより、文脈(シグネチャの違い)に沿う様に述語(識別子)の振る舞いを変えることができます。  
シグネチャをチェックするためには、[入力チェック](#入力チェック)の形式で入力を指定します。これにより、シグネチャが一致する関数の処理が実行されます。  
多重定義した関数の実行は、定義とは逆順にシグネチャをチェックします。これにより、同じ入力形式を持った関数を定義した場合、あとから定義した関数が先に実行されます。  
また、`さらに`を付けずに定義した場合は、上書きされ最新の定義が有効になります。

_多重定義の例：_

```
合成は、関数【入力がa「文字列と…」とb「文字列を」で、aの最初にbを足し、返す】。
合成は、さらに、関数【入力がa「数値に」とb「数値を」で、aにbを足し、返す】。
合成は、さらに、関数【入力がa「文字列を」とb「文字列に」で、bにaを足し、返す】。
※
「あ」と「い」を合成する。(「あい」)
1に2を合成する。(3)
「あ」を「い」に合成する。(「いあ」)
```

関数「合成」を多重定義することによって、引数の種類によって振る舞いの違う述語を実現しています。

#### 多重定義における入力チェック処理

多重定義では、引数のシグネチャをチェックし、以下の様に一致した定義を呼び出します。

1. 関数定義時に、入力の数をキーとし、関数定義の配列を値とする、辞書を作成。
1. 多重定義時に、辞書の配列に関数定義を追加する。
1. 関数実行時に、スタックの引数の数を数え、辞書から一致する関数定義配列を取り出す。
1. 取り出した配列を逆順に(定義が最新のものから)、シグネチャが一致するかチェックする。
1. 一致した場合、引数を対応する識別子に代入し、定義を実行する。
1. シグネチャが一致しない場合、3.の数から１を減じた関数定義配列を取り出し、4.のチェックを行い一致すれば、定義を実行する。
1. 引数の数１つまでチェックしても一致しない場合、可変長の引数としてチェックを行い、一致すれば定義を実行する。
1. 一致しない場合、引数の無い関数定義があれば、実行する。
1. 無い場合、最後の関数定義で引数の入力チェックを行い、エラーメッセージを返す。

以上の様に、スタックで引数をチェックするため、スタックに期待する引数以外のオブジェクトがある場合は、多重定義チェックが誤動作する恐れがあります。誤動作する場合は、スタックと動作を期待する関数定義の入力形式が一致する様に調整が必要です。

#### クロージャ(Closure)

関数はクロージャに対応しており、関数外で定義された識別子をキャプチャすることができます。(算出は引数にできないため、クロージャに未対応)

_クロージャの例：_

```
外側は、関数【
  カウント値は、０。
  内側は、関数【
    カウント値と1を足して、代入する。
    カウント値を返す。
  】。
  内側を返す。
】
外側を実行し、「カウントアップ」に代入する。
カウントアップする。(1)
カウントアップする。(2)
```

関数「内側」で「カウント値」をキャプチャし、保持されたカウント値が「カウントアップ」(関数「外側」が返した関数「内側」)で更新されています。

### 算出(Computation)

`算出`には、主に２つの働きがあります。  
１つ目は、`関数`と同様に、主に入力を得て処理を行い、結果をオブジェクトとして返すことです。  
２つ目は、`型`の値要素として定義し、定義した値の識別子をアクセス(取得と設定)したときの実行処理を表現することです。(既存のプログラミング言語ではアクセサ、あるいはコンピューテッドプロパティと呼ばれ、取得は getter、設定は setter と呼ばれています。)

１つ目については、関数の定義と同じ形式になります。

```
形式１：算出【(入力が、<入力定義>。)(本体が、)<実行処理>】
形式２：算出であって、(入力が、<入力定義>。)(本体が、)<実行処理>
```

また、２つ目については、以下の様な形式になります。

```
形式３：
  算出【
    設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
    取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
  】。
形式４：算出であって、設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】。取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>。】。
```

形式３と４では、「設定」と「取得」の定義を１つの`算出`で行います。(設定、取得の順番は替えられません。「取得」の定義を省略し、「設定」だけにすることは可能です。)

`算出`は、`関数`と違い、**[関数の実行(呼び出し)](#関数の実行function-call)を必要としません。** すなわち、`算出`には、関数呼び出しのための`実行`あるいは`する`が不要で、実行はその評価時に行われます。
(このため、`算出`を`関数`の様に引数として使用することはできません。)  
ただし「設定」は、`算出`を定義した識別子に対し、値を述語`設定`(set)で設定したときに実行されます。

`算出`は、オブジェクトの属性(名詞)を表現したり、(語尾の変化する)動詞や形容詞を表現したりすることに用いることにより、日本語らしい表現を可能とします。
一方、`関数`は、`する`を接続して動詞化するサ変名詞として、もしくは、その他「〜を実行する」を使う名詞としての使い方が適しています。

形式１、２は、形式３、４の「設定」定義が無い形式で、動作に差はありません。  
すなわち、形式３、４の「取得」は、形式１、２と同等です。

_`算出`(形式２)の例：_

```
加えるは、算出【入力がa「文字列に」とb「文字列を」。aとbを足す】。「い」に「ろ」を加える。(「いろ」)
税込は、算出であって、入力が金額。金額を10で割って、金額を足す。100円の税込。(110)
```

算出「加える」は、２つの文字列を足す処理を動詞で表現しています。(連用形による語尾変化にも対応します。)  
算出「税込」は、計算方法を表現する名詞になっており、金額の属性を表しています。

`設定`を伴う形式３、４については、[算出による要素のアクセス](#算出による要素のアクセスcomputed-property)で説明します。

#### `算出`の多重定義

`算出`を１つの定義文で、`設定`と`取得`に副詞`さらに`を付け加えることにより、個別に多重定義することができます。

```
形式５： <識別子>は、算出【
    設定が、【<関数定義１>】。
    設定が、さらに、【<関数定義２>】。
    …
    取得が、【<関数定義３>】
    取得が、さらに、【<関数定義４>】
    …
  】。
```

ここで、<関数定義ｎ>とは、入力定義と実行処理を持つ、通常の関数定義で、<関数定義２>は<関数定義１>の、<関数定義４>は<関数定義３>の多重定義になります。  
(注：ここで、それぞれは、入力形式(シグネチャ)が異なる必要があります。)

また、以下の様に、これとは別に定義文を追加することにより、`算出`を多重定義することができます。

```
形式６： <識別子>は、さらに、算出【<関数定義>】。
```

`算出`の定義が形式１、２である場合、[関数の多重定義](#関数の多重定義function-overloading)と同じく`算出`の「取得」を多重定義したことになります。

_`算出`の多重定義の例：_

```
加えるは、算出【入力がa「数値」とb「数値」で、aにbを足し、返す】。
加えるは、さらに、算出【入力がa「文字列」とb「文字列」で、aにbを足し、返す】。

「あ」に「い」を加える。(「あい」)
1に2を加える。(3)
```

一方、形式３、４の場合は、「取得」と「設定」を別個に多重定義することになります。

```
形式７：
  <識別子>は、さらに、算出【
    設定が、さらに、【<関数定義>】
    取得が、さらに、【<関数定義>】
  】。
形式８：<識別子>は、さらに、算出であって、設定が、さらに、【<関数定義>)】。取得が、さらに、【<関数定義>】。
```

この場合、「取得」と「設定」の後につける`さらに`は必須です。  
この`さらに`を記述しない場合は、「取得」または「設定」を再定義することとなり、それ以前の多重定義は無効になります。

_`算出`の多重定義の例：_

```
(1) 加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。
(2) 加えるは、さらに、算出【取得が、さらに、【入力がa「数値に」とb「数値を」で、aにbを足し、返す】】。
(3) 加えるは、さらに、算出【
      取得が、【入力がa「文字列」とb「文字列」で、aにbを足し、返す】
      取得が、さらに、【入力がa「文字列に」とb「文字列を」で、aにbを足し、返す】
    】。
(4) 「い」に「ろ」を加える。(「いろ」)
(5) １に２を加える。(エラー：入力の型が異なる。入力の型：数値)
```

この例では、「数値」どうしを足す`算出`は、「文字列」どうしを足す`算出`の多重定義で再定義(＊)されています。したがって、「1 と 2 を加える」は、エラーになります。(＊「加える」の(３)の定義の最初の「取得」に`さらに`が無いため再定義となる。)

## 型(Type)と規約(Protocol)

`型`(type)は、オブジェクトの型を定義・表現します。これにより、`数値`や`文字列`の様な組み込み型ではない、独自の型を作ることができます。  
また、`規約`(protocol)は、`型`が準拠するルールを定義・表現します。`規約`により、複数の型で共通となる性質を抽象化することができます。  

規約による共通化された呼び出し(インタフェース)により、呼び出す側は、異なる型を同じ様に扱うことが可能となります。さらに、呼び出された型ごとに、型に応じた振る舞いを定義をすることが可能となります。  
`規約`の定義や準拠の方法については、後述の[`規約`(protocol)](#規約protocol)を参照してください。

組み込み型も内部で規約を利用しており、例えば、`数`は、`配列`、`辞書`、`列挙`等の異なる型のオブジェクトに対し、型に応じた要素数を返すことができます。(参照：[オブジェクトの属性の取得](#値literalとオブジェクトobject))

### 型(Type)

`型`は、値や関数などの定義(要素)の集合です。

```
形式１：型【(本体が、)<識別子>は<定義>…】
形式２：型であって、(本体が、)<識別子>は<定義>…。
```

注：「本体が、」は「本体は、」でも良い。また省略可。

定義した要素は、後述する型から生成されたオブジェクト(インスタンス)が持つ辞書に登録されます。

#### インスタンスの生成(New Operator)

`型`は、雛形であり、以下の述語`生成`によって生成されたオブジェクトが実体(インスタンス)となります。  
`型`に定義された要素には、`型`でなくインスタンスにアクセスします。

```
形式１：(「<識別子>」を)(<引数>で)<型>から生成
形式２：<型>から(<引数>で)「<識別子>」を生成
```

注：<識別子>にはかぎ括弧`「」`が必要

いずれも、<識別子>に、<型>から生成されたインスタンスが代入されます。(引数については後述)  
また、以下の様に定義文でインスタンスを定義することも可能です。

```
形式３：<識別子>は、(<引数>で)<型>から生成
形式４：<識別子>は、<型>から(<引数>で)生成
```

#### インスタンス要素のアクセス

インスタンスに対する要素のアクセスは、他の型と同じく助詞`の`を使いますが、必要に応じて任意の助詞を使うことができます。

```
形式１：<インスタンス>の<要素(識別子名)>
形式２：<インスタンス><任意の助詞><要素(識別子名)>
形式３：<インスタンス><任意の助詞><引数><任意の助詞><要素(識別子名)>
```

_例１：_

```
車の色。(「車」というインスタンスの要素「色」にアクセス(形式１))
40Lを車に給油する。(「車」の要素「給油」という関数に、助詞「に」を使用してアクセス(形式２))
```

また、要素に値を書き込む場合は、述語`設定`(set)を使います。([`設定`(Set)](#設定set)参照)

ただし、インスタンスの要素は、既定では外部からのアクセスを許可していません。  
許可をするためには、述語`利用可能`を使い要素を利用可能にする必要があります。

```
形式４：「<要素(識別子名)>」(と「<要素(識別子名)>」…)は利用可能。
```

注１：<要素(識別子名)>にはかぎ括弧`「」`が必要  
注２：`利用可能`は、本体の中(ブロック)で定義してください。

_例２：_

```
計数は、型であって、【
    カウント値は０。
    値は、算出【カウント値を返す】。
    増やすは、算出【カウント値に１を足して、代入】。
    増やすは、さらに、算出【入力が増分「数値」。カウント値に増分を足して、代入】。
    リセットは、算出【カウント値に０を代入】。
    「値」と「増やす」と「リセット」は利用可能。
】
カウンターは、計数から生成。
(1) カウンターを増やす。カウンターの値。(1)
(2) カウンターを5個増やす。カウンターの値。(6)
(3) カウンターをリセット。カウンターの値。(0)
```

型「計数」には、4つの要素が定義されており、内３つが外部から利用(アクセス)可能です。  
その中で、要素「増やす」(算出)は、副詞`さらに`で多重定義されています。  
また、要素「カウント値」は、他の要素定義内で参照・上書きされています。この様に要素の定義内から外部の要素を上書きする場合は、述語`代入`を使用します。(詳細は、[識別子の有効範囲](#識別子の有効範囲scope)を参照)  

上記(1)では、まず生成された`カウンター`の要素「増やす」(算出)が呼ばれます。  
引数は無いため、１番目の算出が実行され、`カウント値`に１が代入されます。  
そして、`カウンターの値`を実行することにより、算出が呼ばれ、`カウント値`が返ります。

(2)では、引数として`5個`が渡されることにより、２番目に定義された算出が呼ばれます。  
そして、`カウント値`に５が足され、`カウント値`は６になります。  
(注：`個`については、[助詞](#特殊な助詞)を参照)

(3)では、算出「リセット」が実行され、`カウント値`は０になります。

#### インスタンス生成時の初期化(Initialization)

また、型からインスタンスを生成する際に行う「初期化処理」(initializer)を`型`に定義することができます。  
さらに、型からインスタンスを生成する際に、引数(入力)を指定することが可能です。同じ型で、異なる引数で生成することにより、異なる値や振る舞いを持つインスタンスを生成することができます。  
引数は、[関数の入力](#関数の入力定義)と同様に、初期化処理に渡すことができます。同様に[入力チェック](#入力チェック)を行うこともできます。

```
形式：初期化が、【<関数定義>】
```

注：助詞`が`は`は`でも良い。

<関数定義>は、[関数](#関数function)や[算出](#算出computation)の定義と同じです。  

##### 初期化の多重定義

`初期化`も`算出`と同様に副詞`さらに`を使って多重定義をすることが可能です。  
([算出の多重定義](#算出の多重定義)を参照)

```
形式：
初期化が、【<関数定義１>】。
初期化は、さらに、【<関数定義２>】。
…
```

例：

```
甲は、型であって、【
    初期化は、【aは１。bは2。】
    初期化は、さらに、【入力がaで、bは3。】
    初期化は、さらに、【入力がaとb。】
    「a」と「b」は利用可能。
】
乙は甲から生成する。乙のaと乙のbを足す。(3。`生成`で入力の無い１番目の初期化が呼ばれる)
「乙」を、2で甲から生成する。乙のaと乙のbを足す。(5。`生成`で入力が１つの２番目の初期化が呼ばれる)
甲から、3と4で「乙」を生成する。乙のaと乙のbを足す(7。`生成`で入力が２つの３番目の初期化が呼ばれる)
```

多重定義された`初期化`は`生成`に与えられた引数で実行され、インスタンスが生成されます。  
初期化内で定義された識別子や入力識別子は、インスタンス内の辞書に記録されるため、これらを`利用可能`にすることによって、外部から助詞`の`によってアクセスすることが可能になります。

##### 自身の初期化(初期化処理の呼び出し)

また、`初期化`の多重定義において、インスタンス自身を表す`自身`を使って、１つの定義から他の初期化処理を呼び出すことができます。

```
形式：自身の初期化
```

（注：`初期化`内で、自身の初期化を呼び出す際、異なる初期化を呼び出さないと、処理のループが発生します。)

_`初期化`の呼び出し例：_

```
甲は、型であって、【
    初期化は、【入力がaとbとc。】
    初期化は、さらに、【入力がa、aと1と2で、自身の初期化をする。】
    初期化は、さらに、【入力がaとb、aとbと1で、自身の初期化をする。】
    合計は、算出【aとbとcを足す。】
    「合計」は、利用可能。
】
```

多重定義によって、入力の形式(この例では引数の数)によって、異なる初期化処理が呼び出されますが、２番目と３番目の`初期化`は、それぞれ１番目の`初期化`を呼び出し、a と b と c を初期化しています。

#### 算出による要素のアクセス(Computed Property)

`算出`を使うと、インスタンス内の他の要素に間接的にアクセスしたり、一定の処理をしたりすることが可能となります。  
また、通常の関数定義と同様に、入力の指定も可能です。(算出の詳細については、[算出(Computation)](#算出computation)を参照)

*`算出`の形式：*

```
形式１：算出【(入力が、<入力定義>。)(本体が、)<実行処理>】
形式２：算出であって、(入力が、<入力定義>。)(本体が、)<実行処理>
形式３：
  算出【
    設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
    取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
  】。
形式４：算出であって、設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】。取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>。】。
```

`取得`は、他の要素と同様なアクセス方法`<インスタンス>の<要素(識別子)>`で、実行することができます。
また、`設定`は、[述語`設定`(set)](#設定set)を使って、実行します。

_`算出`の定義とアクセス例：_

```
温度は、型であって、【
    摂氏は、0度。
    華氏は、算出【
        設定が、【入力が設定値で、設定値から３２を引いたものに５を掛け、９で割り、摂氏に代入する。】
        取得が、【９に摂氏を掛け５で割ったものに、３２を足す。】
    】。
    「摂氏」と「華氏」は利用可能。
】。
気温は、温度から生成する。
気温の摂氏。(0)
気温の華氏。(32)
気温の要素「摂氏」に20度を設定する。気温の摂氏。(20)
気温の華氏。(68)
気温の要素「華氏」を32度に設定する。気温の摂氏。(0)
```

上記例では、算出により摂氏と華氏の変換を実現しています。`取得`、`設定`、それぞれで変換処理をし、変換した値を返しています。

#### 型の要素(Static Member)

`型`の定義では、インスタンスだけでなく、型自身も要素「`型の要素`」を持つことができます。  
(`型の要素`は、型が内部で持つ辞書に登録されたオブジェクトです。)  
また、`型の要素`はインスタンスとは異なり、全て利用(外部からのアクセス)可能です。

```
形式：型の要素が、【<識別子>は<定義>…】
```

要素へのアクセス方法は、インスタンスではなく型の識別子(型名)を指定する以外は、インスタンスと同じです。([インスタンス要素のアクセス](#インスタンス要素のアクセス)参照)

`型の要素`と`インスタンス要素`の違いは、以下の通りです。

|種類|定義|アクセス方法|`利用可能`の指定
|--|--|--|--|
|型の要素 | 型の要素が、【<識別子>は<定義>…】|<インスタンス>の<要素(識別子名)>|必要
|インスタンス要素|　本体が、【<識別子>は<定義>…】|<型>の<要素(識別子名)>|不要

_例：_

```
挨拶は、型であって、【
    型の要素が、【宛名は、「田中」。本文は、算出【「こんにちは、」と宛名と「さん。」を足す】】。
】。
挨拶の本文を表示。(「こんにちは、田中さん。」)
挨拶の要素「宛名」を「佐藤」に設定した挨拶の本文を表示。(「こんにちは、佐藤さん。」)
```

型「挨拶」の要素「宛名」を変更し、「本文」を読み出しています。

#### 型の定義順序

これまで述べた`型`の要素(`初期化`、`型の要素`など)は、定義する順番があります。  
`型`を定義する場合、以下の順番(*)で、各定義を行います。  
(*必要な定義以外は省略可能。)

```
形式：型【
    準拠する規約は、<規約>。
    型の要素は、【<型の要素定義>】
    初期化は、【<初期化定義>】
    本体は、【<要素の定義>】
】
```

注：「準拠する規約」については、[後述](#準拠する規約)参照。

#### 型の拡張(Type Extension)

副詞`さらに`を使って、既存の`型`の定義を拡張(追加や変更)することが可能です。  

```
形式１：<識別子>は、さらに、型【<拡張定義>】
形式２：<識別子>は、さらに、型であって、【<拡張定義>】
```

<識別子>で定義された型に対し、<拡張定義>で要素を追加または変更します。 

<拡張定義>で定義する要素が、既存の型定義にはない場合は、要素の追加になります。  
また、既存の型定義で定義済みである(同じ識別子名である)場合には、再定義(値または定義の上書き)になります。  

加えて、<拡張定義>で、副詞`さらに`を使用することにより、関数定義を持つ`初期化`および`関数`、`算出`を多重定義することができます。

_拡張定義の例：_

```
甲は、型であって、【
    初期化は、【入力がaとbとc。】
    初期化は、さらに、【入力がaで、aと1と2で、自身の初期化をする。】
    合計は、算出【aとbとcを足す。】
    「合計」は、利用可能。
】
甲は、さらに、型であって、【
    初期化は、さらに、【入力がaとbで、aとbと1で、自身の初期化をする。】
】
※
乙は、1と2と3で、甲から生成する。乙の合計（6)
乙は、1と2で、甲から生成する。乙の合計（4)
乙は、1で、甲から生成する。乙の合計(4)
```

型「甲」は、型の定義で、初期化を拡張(多重定義)しています。  
そして、`さらに`よって拡張された型で、既存の初期化を`さらに`を使った追加定義で多重定義をしています。  
追加された初期化により、引数が２つ（１と２）で生成した乙の合計は(1+2+1 で)４になります。

### 規約(Protocol)

`規約`は、型のインターフェイスを規定します。

準拠した`型`が持つべき要素(値や関数)の形式を定め、これを複数の`型`で準拠し実装することにより、複数の型に共通する性質を抽象化することができます。  

#### 規約の定義

`規約`は、以下の様な形式をしています。

```
形式１：規約【(準拠する規約は、<規約>。)(条項は、)<要素の定義>。】
形式２：規約であって、【(準拠する規約は、<規約>。)(条項は、)<要素の定義>。】
```

`準拠する規約`、および`条項`は、それぞれ複数定義をすることができます。

#### 準拠する規約

`準拠する規約`とは、当該規約が前提とする規約であり、複数の規約を指定することができます。  
`型`が規約に準拠する際には、ここでに記述した<規約>にも準拠する必要があります。

```
形式：(準拠する)規約は、<規約１>(と、<規約２>と、…)。
```

注：「準拠する」は省略可。「規約は」は「規約が」も可。「と、」は「、」でも可。

<規約 n>は、定義した規約の識別子名で、かぎ括弧`「」`は無くても構いません。

#### 条項(Clauses)

`条項`とは、`型`が準拠する要素(識別子)の形式(型指定)であり、以下の様な形式で定義します。

```
形式１：<識別子>は、「<型名>」
形式２：型の<識別子>は、「<型名>」
```

注：<型名>を囲うかぎ括弧`「」`は必要。

条項として、要素の<識別子>とその<型名>を規定します。  
形式２は、`型の要素`([参照「型の要素」](#型の要素static-member))の規定になります。

さらに、`関数`、`算出`(`設定`および`取得`)では、その入力形式を規定することができます。

```
形式３：(型の)<識別子>は、関数【入力が<入力形式>】
形式４：(型の)<識別子>は、算出【入力が<入力形式>】
形式５：(型の)<識別子>は、算出【
                          設定は、【入力が<入力形式>】
                          取得は、【入力が<入力形式>】
        】
```

(注：形式５で、「取得は、」の定義は、省略可。)

`関数`と`算出`で、入力形式の規定が不要である場合は、形式１、２の様にそれぞれの<型名>だけ記述します。

#### 規約の準拠方法

`型`を、規約に準拠させるためには、最初に[`準拠する規約`の定義](#準拠する規約)をします。  
さらに、規約の条項の定義に沿った型を持った<識別子>を全て定義します。  
必要に応じて、`関数`と`算出`では、指定した入力形式に従った`関数`、`算出`を定義します。  

準拠する規約が、さらに規約に準拠している場合、`型`は、すべての規約に準拠する(条項を実装する)必要があります。

規約に準拠した定義が見つからない、または、入力形式が異なる場合は、エラーメッセージを出力します。

_準拠方法の例：_

```
『通貨表記』は、規約であって、【
    記号は、「文字列」
    コードは、「文字列」
】
ユーロは、型であって、準拠する規約は、『通貨表記』。記号は「€」。コードは「EUR」。
米ドルは、型であって、準拠する規約は、『通貨表記』。記号は「$」。コードは「USD」。
国名は、列挙であって、要素が、米国と、スペインと、英国と、ギリシアと、日本。
表記は、関数であって、【入力が通貨国「国名」。
    通貨国が、
    ・スペインまたは・ギリシアの場合、ユーロから生成し、返す。
    ・米国の場合、米ドルから生成し、返す。
    それ以外は、無を返す。
】
※
・ギリシアで表記したコードを表示する。(EUR)
・スペインで表記した記号を表示する。(€)
・米国で表記したコードを表示する。(USD)
・英国で表記したコードを表示する。(『コード』(識別子)が定義されていない。)
```

例では、関数「表記」は、入力の国名に応じて、規約「通貨表記」に準拠した型(「ユーロ」や「米ドル」)からインスタンスを生成し、これにアクセすることにより、通貨の「記号」と「コード」を表示します。  
英国の様に対応する型が定義されていない場合、関数「表記」は`無`を返すため、未定義の「コード」を参照するため、エラーが表示されます。

注：規約『通貨表記』の二重かぎ括弧は規約を目立たせる目的で、無くても構いません。また、「表記した」は「表記し、」でも同じです。

#### 規約の実装定義(Protocol Extension)

`規約`に、副詞`さらに`を使って、`規約`の既定(デフォルト)の実装を定義することが可能です。

```
形式１：
    <識別子>は、規約であって、<規約の定義>。
    <識別子>は、さらに、型であって、<規約の実装定義>。
形式２：
    <識別子>は、規約【<規約の実装定義>】
    <識別子>は、さらに、型【<規約の実装定義>】
```

この実装定義により、`型`で同名の要素（関数や算出など）を定義しなかった場合の、既定の振る舞いを定義することができます。

_規約の実装定義の例：_

```
Objectは、規約【countは、「算出」。】
Objectは、さらに、型【countは、算出【「エラー：数えることはできない。」】】
Numberは、型【
    準拠する規約は、Object。
    初期化は、【入力はn「数値」、numberはn。】
】
Booleanは、型【
    準拠する規約は、Object。
    初期化は、【入力はb「真偽値」、booleanはb。】
】
Stringは、型【
    準拠する規約は、Object。
    初期化は、【stringは「」】
    初期化は、さらに、【入力はs「文字列」、stringはs。】
    countは、算出【stringの数】
】
Arrayは、型【
    準拠する規約は、Object。
    初期化は、【arrayは配列【】】
    初期化は、さらに、【入力はa「配列」、arrayはa。】
    countは、算出【arrayの数】
】
※
1でNumberから生成し、count。(「エラー：数えることはできない。」)
真でBooleanから生成し、count。(「エラー：数えることはできない。」)
「あいうえお」でStringから生成し、count。(5)
配列【1,2,3】でArrayから生成し、count。(3)
```

例では、算出「count」を実装した String と Array は要素の数を算出し、実装していない Number と Boolean は既定実装であるエラー出力をします。  

このように、規約に準拠する型は、必要に応じて固有の実装を与えることができ、未定義の要素については規約側で定めた既定の実装（ここではエラー出力）を利用することができます。

## 述語(Predicate)

主に、型に共通、または特定の型に依存しない述語について、以下に説明します。

### オブジェクトおよびその要素を操作する述語

#### `代入`(Assign)

オブジェクトに値を代入します。  
対象となるオブジェクトは、識別子、配列の要素、列挙子です。

#### 識別子に代入

```
形式１：<値>を<識別子>に代入
形式２：<識別子>に<値>を代入
```

形式１と形式２は、既存の識別子に値を代入します。

識別子を定義してない場合、<識別子>には以下の様に`「」`(かぎ括弧)が必要です。(注：`『』`(二重かぎ括弧)は使えません。)

```
形式３：<値>を「<識別子>」に代入
形式４：「<識別子>」に<値>を代入
```

`代入`は、定義文で識別子を定義(または再定義)したのと同じであり、文脈や意図によって選択が可能です。  
また、[代入文](#代入文assignment-statement---要素への代入設定)を使用して、代入することも可能です。

_識別子に代入の例：_

```
(1) 甲は1。甲に「い」を代入する。甲。(「い」)
(2) 「甲」に1を代入。甲。(1)
(3) 1と2を足し、「乙」に代入する。乙。(3)
```

(1)では、甲を定義した後、「い」で代入して値を上書きしています。  
(2)と(3)では、それぞれ、`甲は１。`、`乙は1と２を足す。`と同じことを`代入`で行なっています。

#### 計算をして代入(Compound Assignment)

識別子に、算術演算等の計算・操作をし、結果を代入します。  
 C言語の様な既存プログラミング言語では、`a += 1`などの形式で表現され、`+=`を「複合代入演算子(compound assignment operator)」と呼んでいます。

```
形式５：<識別子>(に)<計算し>て代入
```

計算に使える述語は以下の通りです。
- `足す`、`掛ける`、`割る`、`引く`、`負数`、`追加`、`削除`、`逆順`(注）

識別子は、**定義済みである必要**があります。  
また、述語`代入`の前には、助詞`て`を記述する必要があります。  

_識別子に計算をして代入する例：_

```
xは１。xに1を足して代入。x。(2)
xは１。xから1を引いて代入。x。(0)
xは１。xを3から引いて代入。x。(2)
xは２。xで6を割って代入。x。(3)
xは１。xを負数にして代入。x。(-1)
xは配列【１、２】。xに３を追加して代入。x。(配列【1、2、3】)
xは辞書【「い」が1、「ろ」が2】。xから「い」を削除して代入。x。（辞書【「ろ」が2】)
xは「あいうえお」。xを逆順にして代入。x。(「おえういあ」)
xは２。xに2を掛け、3を足し、4を引いて代入する。x。(3)
```

この様に、計算と代入の式を簡潔に記述することが可能です。

注：  
計算して代入は、単一の計算だけでなく、例の`xに2を掛け、3を足し、4を引いて代入する。`の様に、識別子に対して、連続して計算を行うことができます。  

#### 配列に代入

配列の指定位置に値を代入します。([配列要素のアクセス](#配列要素のアクセス)を参照)

```
形式６：<配列>の位置<数値>に<値>を代入
形式７：<値>を<配列>の位置<数値>に代入
形式８：<配列>の位置『<識別子>』に<値>を代入
形式９：<値>を<配列>の位置『<識別子>』に代入
```

注：[代入文](#代入文assignment-statement---要素への代入設定)でも同じことができます。

#### 辞書に代入

辞書の指定キーに値を代入します。([辞書要素のアクセス](#辞書要素のアクセス)を参照)

```
形式１０：<辞書>のキー<キー>に<値>を代入する
形式１２：<辞書>のキー『<識別子>』に<値>を代入する
形式１３：<値>を<辞書>のキー<キー>に代入する
形式１４：<値>を<辞書>のキー『<識別子>』に代入する
```

注：[代入文](#代入文assignment-statement---要素への代入設定)でも同じことができます。

#### 列挙子に代入

列挙の要素に値を代入したオブジェクトを得ることができます。([列挙要素のアクセス](#列挙要素のアクセス)を参照)

```
形式１５：<値>を<列挙子>に代入
形式１６：<列挙子>に<値>を代入
```

注：いずれも<値>を列挙子に代入した<要素オブジェクト>を返します。

#### 関数の呼び元への代入

`関数`や`算出` 内で、呼び出し元の識別子や、インスタンスの要素に値を代入することができます。

ローカルに同名の識別子が無く、呼び元やインスタンスの識別子を指定し代入すると、値が代入(上書き)されます。  
ローカルに同名の識別子がある場合は、予約語`外部`を指定することにより、呼び元に代入することが可能です。

代入する識別子は、辞書に既存(定義済み)である必要があります。

_例:_

```
(1) 甲は配列【１、２、３】。乙は１。関数【甲は１。外部「甲」の位置『乙』に０を代入】を実行。甲。(配列【1,0,3】)
(2) 甲は配列【１、２、３】。乙は２。関数【乙は１。外部「甲」の位置『外部「乙」』に０を代入】を実行。甲。(配列【1,2,0】)
(3) 甲は配列【１、２、３】。乙は２。関数【乙は１。外部「甲」の位置「外部『乙』」に０を代入】を実行。甲。(配列【1,2,0】)
```

(1)では、関数で外部の`甲`と`乙`にアクセスし、配列`甲`に代入します。  
(2)と(3)では、関数で配列`甲`の位置`乙`(外部)に 0 を代入します。

配列に代入する位置に識別子を使用する場合、二重かぎ括弧`『』`を使用しますが、(2)(3)の例の様に、外部の識別子を指定する場合、`『外部「乙」』`か`「外部『乙』」`の様にかぎ括弧を入れ子に指定します。(同種のかぎ括弧使うと解析エラーになります。)

#### `設定`(Set)

オブジェクトの要素に値を設定します。

対象となるオブジェクトは、インスタンスの要素、および型の要素です。  
要素が`算出`である場合は、述語`設定`により算出の設定処理を行います。([算出による要素のアクセス](#算出による要素のアクセスcomputed-property)参照)

```
形式１：<値>(を)<オブジェクト>の要素「<識別子>」に設定する。
形式２：<オブジェクト>の要素「<識別子>」に<値>を設定する。
形式３：<オブジェクト>の要素「<識別子>」を<値>に設定する。
```

注１：形式２と形式３では、格助詞`に`と`を`が逆になっています。  
注２：[`代入文`による設定](#代入文assignment-statement---要素への代入設定)も可能です。

_設定の例：_

```
自動車は、型であって、【
    型の要素が、【ハンドルは「右」。】
    初期化が、【入力が残量で、燃料量は、残量。色は「黒」。】
    給油は、関数であって、【入力が給油量で、
        燃料量に給油量を足して、代入し、燃料量を返す。
    】
    「燃料量」と「給油」と「色」は利用可能。
】
自動車の要素「ハンドル」を「左」に設定する。
黒い車は、10Lで自動車から生成する。
30Lを黒い車に給油する。
黒い車の要素「色」に「白」を設定する。
※
自動車のハンドル(「左」)
黒い車の燃料量。(40)
黒い車の色。(「白」)
```

例では、型の要素「ハンドル」と、インスタンス「黒い車」の要素「色」に、それぞれ値を設定しています。

#### `追加`(Append)

オブジェクトに、要素またはオブジェクトを追加します。  
対象となる<オブジェクト>は、`配列`と`辞書`です。

```
形式１：<オブジェクト>に<要素>を追加する。
形式２：<要素>(を)<オブジェクト>に追加する。
形式３：<オブジェクト１>に<オブジェクト２>を追加する。
```

注：オブジェクトが辞書の場合、要素は「<キー>が<値>」になります。  
注：形式３で追加できるオブジェクトは、同型のオブジェクトです。

`配列`への要素/配列の追加については、[配列要素のアクセス](#配列要素のアクセス)を参照。  
また、`辞書`への要素/辞書の追加については、[辞書要素のアクセス](#辞書要素のアクセス)を参照。

#### `削除`(Remove)

オブジェクトから、要素を削除します。

```
形式１：<配列>から<数値(位置)>を削除する。
形式２：<配列>から「先頭」/「後尾」/「全て」を削除する。
```

注：「先頭」は「最初」でも良い。「後尾」は「最後」でも良い。

`配列`の削除については、[配列要素のアクセス](#配列要素のアクセス)を参照。

```
形式３：<辞書>から<キー>を削除する。
形式４：<キー>を<辞書>から削除する。
形式５：<辞書>から「全て」を削除する。
```

`辞書`の削除については、[辞書要素のアクセス](#辞書要素のアクセス)を参照。

また、述語`削除`により、識別子とそれに紐づくオブジェクトをローカルの辞書から削除することができます。

```
形式６：<識別子>を削除する。
```

_オブジェクトの削除例：_

```
ディレクトリパスは、「/Users/username/Downloads」。
ディレクトリパスを削除する。(『ディレクトリパス』が辞書から削除される。)
ディレクトリパスを表示する。(エラー：『ディレクトリパス』(識別子)が定義されていない。)
```

#### `含む`(Contains)

オブジェクトに、値が含まれているか否かを判定します。  
対象となるオブジェクトは、`文字列`、`範囲`、`配列`、`辞書`です。

```
形式：<オブジェクト>が<値>を含む。(真偽値を返す)
```

_`含む`の例：_

```
「かきくけこ」が「く」を含む。(真)
範囲【1以上5未満】が5を含む。(偽)
配列【１、２、３、４、５】が3を含む。(真)
配列【１、２、３、４、５】が配列【１、３】を含む。(偽)
配列【１、２、３、４、５】が範囲【６以上】を含む。(偽)
```

また、オブジェクトが関数で定義した条件を満たす値/要素を含むか否かを判定します。  
関数では、入力(オブジェクトの要素)が満たす条件を記述します。

```
形式：<オブジェクト>が<関数(条件)>を含む。(真偽値を返す)
```

`関数`を使った`含む`の例：

```
配列【１、２0、３、４0、５】が、関数【入力が数値で、数値が10より大きい】を含む。(真)
辞書【「あ」が１、「い」が２、「う」が30】が、関数【入力がキーと値で、値が10より大きい】を含む。(真)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。

#### `繰り返す`(Foreach)

オブジェクトの要素ごとに、関数で定義した処理を実行します。  
関数では、オブジェクトの要素が入力になります。

```
形式：<オブジェクト>で<関数>を繰り返す。
```

`繰り返す`の例：

```
合計は０。範囲【1から９まで】で関数【入力は数字、合計に数字を足して代入】を繰り返し、合計を表示。(45)
合計は０。配列【１、２、３、４、５、６、７、８、９】で関数【入力は数字、合計に数字を足して代入】を繰り返し、合計を表示。(45)
合計は０。辞書【1が１、2が２、3が３、4が４、5が５、6が６、7が７、8が８、9が９】で関数【入力は索引と値、合計に値を足して代入】を繰り返し、合計を表示。(45)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。

#### `写像`(Map)

オブジェクトの各要素に、関数で定義した処理を行った(変換した)結果で、オブジェクトを再構成します。  
すなわち、オブジェクトの各要素を関数で、写像(変換)します。

```
形式１：<オブジェクト>を<関数>で写像する。
```

関数では、オブジェクトの要素を入力とし、変換した結果を出力します。

`写像`の例：

```
二倍は、関数【入力が数値で、数値に２を掛ける】。
配列【１、２、３、４、５】を二倍で写像する。(配列【2、4、6、8、10】)
範囲【1から5まで】を二倍で写像する。(配列【2、4、6、8、10】)
辞書【「あ」が１、「い」が２、「う」が30】を、関数【入力がキーと値で、値に2を掛ける】で写像する。(配列【4、２、60】)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。また、辞書の要素の順序は不定なので、結果の配列の順序も不定です。

例では、関数「二倍」が、オブジェクトの要素を入力とし、２を掛けた結果を出力し、配列を再構築しています。

また、`写像`は`範囲`を、範囲に含まれる数値の配列に変換します。

```
形式２：<範囲>を写像する。
```

_配列への変換の例：_

```
範囲【1以上5以下】を写像する。(配列【１、２、３、４、５】)
範囲【1以上6未満】を写像する。(配列【１、２、３、４、５】)
```

辞書を配列に写像するためには、関数で、キーまたは値のいずれを変換するのか指定する必要があるため、形式１で記述します。

_辞書の配列への変換例：_

```
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を関数【入力がキーと値。キー】で写像し、並べ替える。(配列【１、２、３、４、５】)
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を関数【入力がキーと値。値】で写像し、並べ替える。(配列【「１」、「２」、「３」、「４」、「５」】)
```

#### `絞り込む`(Filter)

関数で定義した条件で、オブジェクトの要素を絞り込みます。  
対象となるオブジェクトは、`配列`と`辞書`です。

```
形式：<オブジェクト>を<関数(条件)>で絞り込む。
```

_例：_

```
配列【１、２0、３、４0、５】を、関数【入力が数値で、数値が10より大きい】で絞り込む。(配列【20、40】)
辞書【「あ」が１、「い」が２、「う」が30】を、関数【入力がキーと値で、値が10より大きい】で絞り込む。(辞書【「う」が30】)
```

注：辞書の場合、関数の入力は２つ(キーと値)必要です。

#### `まとめる`(Reduce)

<オブジェクト>の要素を<初期値>と<関数>で一つにまとめます。  
対象となるオブジェクトは、`配列`と`辞書`と`範囲`です。

```
形式：<オブジェクト>を<初期値>と<関数>でまとめる。
```

_例：_

```
配列【「あ」、「い」、「う」、「え」、「お」】を、「」と関数【入力が初期値と文字で、初期値に文字を足す】でまとめる。(「あいうえお」)
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を、0と関数【入力が初期値とキーと値で、初期値にキーを足す】でまとめる。(15)
範囲【1から5まで】を、０と関数【入力が初期値と数値で、初期値に数値を足す】でまとめる。(15)
```

注：辞書の場合、関数の入力は２つ(キーと値)必要です。

#### `並べ替える`(Sort)

オブジェクトの要素を指定順に並べ替えます。  
対象となるオブジェクトは、`配列`です。また、対象となる要素は、`数値`または`文字列`です。

```
形式１：<配列>を<関数>で並べ替える。(要素を関数で定義した順に並べ替えます。)
形式２：<配列>を「昇順」に並べ替える。(要素を昇順に並べ替えます。)
形式３：<配列>を「降順」に並べ替える。(要素を降順に並べ替えます。)
形式４：<配列>を並べ替える。(要素を昇順に並べ替えます。)
```

_例：_

```
配列【３、１、４、２、５】を並べ替える。(配列【１、２、３、４、５】)
配列【「お」、「い」、「え」、「う」、「あ」】を「昇順」に並べ替える。(配列【「あ」、「い」、「う」、「え」、「お」】)
配列【３、１、４、２、５】を「降順」に並べ替える。(配列【５、４、３、２、１】)
配列【３、１、４、２、５】を、関数【入力が甲と乙で、甲が乙より大きい】で並べ替える。(配列【５、４、３、２、１】)
```

#### `逆順`(Reverse)

```
形式：<オブジェクト>を逆順にする。
```

<オブジェクト>の要素を逆順に並べ替えます。  
対象となるオブジェクトは、`配列`と`文字列`です。

_例：_

```
配列【３、１、４、２、５】を逆順にする。(配列【5,2,4,1,3】)
「いろはにほへと」を逆順にする。(「とへほにはろい」)
```

### コンソール、音声の出力

#### `表示`(Print)と`改行`(Newline)、`尋ねる`(Input)

`表示`(print)は、コンソールにテキストを出力します。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)を表示。
```

助詞`と`で区切られた<オブジェクト>を表示します。各オブジェクト間は、改行されます。

また、述語`改行`(newline)は、改行をします。

_文字列の表示例：_

```
「みなさん、こんにちは。」を表示する。(みなさん、こんにちは。)
「みなさん、」と「こんにちは。」を表示する。(
みなさん、
こんにちは。
)
「みなさん、」に「こんにちは。」を足して表示。(みなさん、こんにちは。)
```

さらに、述語`尋ねる`は、コンソールにテキストを表示し、キーボードの入力を受け付けます。  
改行後に、入力された文字列は、スタックに格納されます。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)と尋ねる。
```

(注：尋ねる問いがない場合、`「」と尋ねる`としてください。)

ここで、表示するオブジェクトに関しては、`表示`と同じです。

_`尋ねる`の例(コンソールのイメージ)：_

```
>> 「入力してください。」と尋ねる。
入力してください。
入力した文字列
入力: (入力した文字列)
>>
```

「入力してください。」に対し、「入力した文字列」を入力した結果、スタックに「入力した文字列」が格納されています。

#### エスケープ文字(Escape Sequence)

文字列には、以下の形式１から形式１３の様な、**エスケープ文字**(escape sequence)を含むことができます。

```
形式１：\改行なし (改行を抑止する)
形式２：\末尾 (改行の代わりに以降の文字を表示する)
```

`\改行なし`を文字列に入れることにより、改行を抑止することができます。  
また、`\末尾`は、文字列の改行の代わりに指定した文字を表示します。

_`\改行なし`の例：_

```
「こんにちは、\改行なし」と「みなさん。」を表示する。(こんにちは、みなさん。)
```

さらに、他のコンピュータ言語で使用される以下のエスケープ文字も使用可能です。

```
形式３：\n (改行。ラインフィード)
形式４：\r (改行。キャリッジリターン)
形式５：\t (タブ)
形式６：\\ (バックスラッシュ)
形式７：\0 (null文字)
```

_エスケープ文字の例：_

```
(1)「い\nろ\nは」を表示する。(
い
ろ
は
)
(2)「あ\末尾\t」と「いうえお」を表示する。(あ	いうえお)
```

(２)の例では、「あ」の後の改行の代わりに、`\t`(タブ)を表示しています。

さらに、以下のエスケープ文字により、文字列の中に識別子の内容(値または定義)を取り込むことも可能です。

```
形式８：『<識別子>』
形式９：\（<識別子>）
```

注：かっこ`()`は、全角・半角共に可です。
例については、[次項](#定義内容の表示)を参照。

かぎ括弧`「」`および二重かぎ括弧`『』`を文字として、文字列に表示するためには、以下の様に指定します。

```
形式１０：\「
形式１１：\」
形式１２：\『
形式１３：\』
```

#### 定義内容の表示

定義した識別子の内容(値や定義)を表示することができます。

_識別子の表示例：_

```
二倍は、関数【入力がxで、xに2を掛ける】。
二倍を表示する。(関数であって、【入力が、xであり、本体が、xに2を掛ける】)
２を二倍し、表示。(4)
※
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日を表示する。(列挙であって、【要素が、月と、火と、水と、木と、金と、土と、日】)
・月を表示する。(列挙型名は曜日で、列挙子は月、値は月曜。)
```

ただし、`算出`を定義した識別子を表示すると、`算出`が先に実行されるため、定義を表示することはできません。  
`算出`の定義内容を表示するためには、予約語`識別子`を使います。(以下の例(2)を参照)

_算出の表示例：_

```
加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。

(1) 加えるを表示。(エラー：入力の数が足りていない。必要数：2)
(2) 識別子「加える」を表示。(算出であって、【取得は、【入力が、a「数値」とb「数値」であり、本体が、aにbを足し、返す】】)
(3) 「\『加える\』は、『加える』」を表示。(『加える』は、算出であって、【取得は、【入力が、a「数値」とb「数値」であり、本体が、aにbを足し、返す】】)
```

(1)のように、`識別子`をつけないと、表示する前に`算出`「加える」が実行されるため、エラーになります。  
(3)の例では、エスケープ文字形式`『<識別子>』`を使うことにより、「加える」の定義を表示しています。

また、以下の例の様に、識別子の定義内容にエスケープ文字が含まれ、それを無効化して表示したい場合も、`識別子`を使います。

_スケエープ文字の無効化の例：_

```
文字列は、「い\nろ\nは」。
(4) 識別子「文字列」を表示する。(い\nろ\nは)
(5) 文字列を表示する。(
い
ろ
は
)
```

(4)のように、`識別子`をつけることにより、エスケープ文字`\n`による改行が抑止されます。

注： [予約語`ファイル`](#ファイルfile)を使って、ファイルの内容を表示する場合も、エスケープ文字は無効です。

#### `音読`(Read)

`音読`(read)は、テキストを音声で読み上げます。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)を音読
```

助詞`と`で区切られた<オブジェクト>を音読します。エスケープ文字は無効です(作用しない)。

_音読の例：_

```
「みなさん、こんにちは」を音読する。
```

<識別子>の内容(定義内容)も、表示と同じ様に音読します。

_識別子の音読例：_

```
加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。
識別子「加える」を音読。
```

また、テキストファイルを音読することも可能です。

_ファイル音読の例：_

```
ファイル「サンプル.txt」を音読する。
```

### ファイル操作

#### `ファイル`(File)

予約語`ファイル`(file)により、ファイルにアクセスすることが可能です。ファイルに対し可能な処理は、以下のとおりです。

```
形式１：ファイル「<ファイル名>」を表示。(コンソールにファイル内容を表示する)
形式２：ファイル「<ファイル名>」を音読。(音声でファイル内容を音読する)
形式３：ファイル「<ファイル名>」を実行。(ファイル内容をプログラムとして実行する)
```

アクセスできるパスは、`/usr/<ユーザ名>/Documents`(書類フォルダ)です。  
識別子「ディレクトリパス」にパスを設定することにより、アクセスできるパスを変更できます。  
(注： デフォルトの書類フォルダに戻すには、[述語`削除`](#削除remove)を使って「ディレクトリパス」を削除します。)

_例：_

```
>> ディレクトリパスは、「/Users/<ユーザ>/Downloads」
(<ユーザ>のダウンロードフォルダにアクセスできます。)
```

#### `ファイル一覧`(Files)

予約語`ファイル一覧`(files)により、ファイルの一覧をファイル名(文字列)の`配列`として返します。

```
形式：ファイル一覧
```

`ファイル一覧`を行うパスも`ファイル`と同じく、「ディレクトリパス」により変更できます。

_ファイル一覧の例：_

```
ファイル一覧を表示する。(ファイル一覧の配列を表示します。)
ファイル一覧を反復【入力がファイル名で、ファイル名を表示する】。
(ファイル一覧を、ファイル名ごとに改行して表示する。)
```

### スタック操作

スタックは、予約語の述語、関数、算出、型の初期化の引数として使われます。これら述語等は、引数をチェック、操作して必要な入力とする機構を備えているため、通常は、スタックを操作する必要はありません。  
プログラムの動作確認や、用意された機構で実現できない場合に、以下のスタック操作の述語を使います。

#### `積む`(Push)と`得る`(Pull)と`写す`(Duplicate)

- `積む`は、引数の値をスタックに格納します。複数の引数を格納することはできません。

```
形式：<値>を積む
```

_`積む`の例：_

```
(1) 1を積む。(1)
(2) 1と２に３を４が５を積む。(1と 2に 3を 4が 5)
```

(２)の例は、「５を積む」以外は、助詞(格)の付いた句の状態でスタックに格納されています。

- `得る`は、スタックから値を取り出し、返します。

```
形式１：(「<識別子１>」(「<識別子２>」…)に)(n個)得る。
形式２：(「<識別子１>」(「<識別子２>」…)に)「値」を(n個)得る。
形式３：(「<識別子１>」(「<識別子２>」…)に)「数値」を(n個)得る。
```

注： 識別子が既存の場合、かぎ括弧`「」`は不要です。

1. 「<識別子>」を指定すると、<識別子>にスタックから値を取得する。
1. 「値」を指定すると、スタックから(格を除いた)値を取り出す。
1. 「数値」を指定すると、スタックから数値を取り出す。(無い場合は、無)
1. 個数を指定(n 個)すると、指定数分をスタックから値を取得する。複数の値に対し、１つの識別子を指定した場合、配列に値を取得し、識別子に代入する。指定個数を取得できない場合、`無`を返す。
1. 複数の識別子を指定した場合、識別子ごとに値を代入する。(指定個数があっても無視)

_`得る`の例：_

```
1を積む。甲は得たもの。甲。(1。甲に１が代入され、スタックは空になる。)
2を積む。「甲」に得る。甲。(2。甲に２が代入され、スタックは空になる。)
13 14 15を積む。「甲」に３個得る。甲。(配列【13, 14, 15】)
16を積む。甲は3個得たもの。甲。(無)
17と18を積む。捨てる。「甲」に「数値」を得る。甲。(17)
「a」を積む。甲は「数値」を得たもの。甲。(無)
23と24を積む。「甲」と「乙」に得る。甲に乙を足す。(47)
```

- `写す`は、スタックから値をコピーし返します。形式は`得る`と同じです。

```
形式１：(「<識別子１>」(と「<識別子２>」…)に)(n個)写す。
形式２：(「<識別子１>」(と「<識別子２>」…)に)「値」を(n個)写す。
形式３：(「<識別子１>」(と「<識別子２>」…)に)「数値」を(n個)写す。
```

_`写す`の例：_

```
10と11と12を積む。「甲」に３個写す。甲。(10と 11と 12 配列【10と、11と、12】。)
※ スタックに積んだ値はそのままで、配列にコピーされた値が甲に代入される。
25と26を積む。「甲」と「乙」に写す。甲から乙を引く。(25と 26 -1)
```

#### `捨てる`（Drop)

スタックの値を(最新のものから)、指定した個数を削除します。指定値がない場合、最新の値を削除します。  
また、スタックの値の数より大きい数を指定した場合、全てを削除します。

```
形式：(<数値>個)捨てる
```

_`捨てる`の例：_

```
１と２と３を積む。(1と 2と 3)
２個捨てる。(1と)
捨てる。()
１と２と３を積む。(1と 2と 3)
５個捨てる。()
```

#### `空`(Empty)

`空`(から)は、スタックを空にします。

```
形式１：空
形式２：空にする。
```

注：[`<オブジェクト>が空`の形式](#値literalとオブジェクトobject)では、オブジェクトの要素が空かの判定をします。

_`空`の例：_

```
１と２と３を積む。(1と 2と 3)
空にする。()
```

#### `入れ替える`(Swap)

```
形式１：<識別子１>と<識別子２>を入れ替える。(２つの識別子の値を入れ替えます。)
形式２：<識別子１>を<識別子２>と入れ替える。(２つの識別子の値を入れ替えます。)
形式３：入れ替える。(２つのスタックの値を入れ替えます。)
```

注：形式３で、スタックの値の格が`と`と`を`である場合、形式１、２として処理されます。また、値が２つない場合は、エラーを返します。

### その他

#### `識別子一覧`(Identifiers)

予約語`識別子一覧`(identifiers)により、ローカルの辞書を、識別子(文字列)と定義内容(文字列）の辞書にして返します。

```
形式：識別子一覧
```

_識別子一覧の例：_

```
識別子一覧を表示する。(識別子一覧の辞書を表示します。)
識別子一覧で関数【入力がキーと値で、キーを表示する】を繰り返す。(識別子一覧を一行ずつ表示する。)
識別子一覧で関数【入力がキーと定義で、「\(キー)は、\(定義)」を表示する】を繰り返す。(ローカル辞書の、識別子とその定義を表示する。)
```


#### `する`(`し`)

直前のオブジェクトが、`関数`(または`関数`を含む`句`)である場合、その関数を実行します。([関数の実行](#関数の実行function-call)参照。)

直前のオブジェクトが、`関数`でない場合、オブジェクトの値を取り出し、返します。オブジェクトがスタックにない場合は、何もしません。  
これにより、予約語の様に本来、`する`が不要な述語でも、`する`をつなげて問題ありません。(例：`追加する`、`空にする`。)

注：文の中で、オブジェクトを返す(スタックに格納する)述語がない場合、上記の後者の動作をするため、それ以前のスタックのオブジェクトに`する`が作用する場合があります。

_例：_

```
挨拶は、型であって、【
    型の要素が、【宛名は、「田中」。本文は、算出【「こんにちは、」と宛名と「さん。」を足す】】。
】。
挨拶の要素「宛名」を「佐藤」に設定した挨拶の本文。(「こんにちは、佐藤さん。」)
挨拶の要素「宛名」を「鈴木」に設定した挨拶の本文。(こんにちは、佐藤さん。た こんにちは、鈴木さん。)
```

上記注で示したとおり、例の最後の文`挨拶の要素「宛名」を「鈴木」に設定`は、値を返さないため、`し`(する)が、直前のオブジェクト`「こんにちは、佐藤さん。」`を返したことにより、次の助詞`た`をつなげ`句`を作っています。(実行前にスタックを空にすることで、解消します。)

#### `もの`

直前のオブジェクトから値を取り出し、続く助詞をつなげ句を作ります。  
 `もの`を使うと、式を、まとまった句(例では`10と2を掛けたものを`)の様に見せることができるため、可読性が良くなります。

以下の例では、１つ目の`もの`を評価した時点で`5に、10と2を掛けたものを`が、`5に20を`になります。この評価順に記述すると、以下の様になります。(かっこ内は、スタックのデータイメージ)

1.  5 に → (5 に)
1.  10 と → (5 に 10 と)
1.  2 を → (5 に 10 と 2 を)
1.  掛けた → (5 に 20)
1.  ものを → (5 に 20 を)

4.で10と2を掛けた結果の20と、`ものを`の助詞`を`で句をつくり、`20を`がスタックに格納されます。

_`もの`の例：_

```
5に、10と2を掛け、足し、15を3で割り、足し、2を掛け、-10を足す。(50)
5に、10と2を掛けたものを足し、15を3で割ったものを足し、2を掛け、-10を足す。(50)
```

数式で書くと、$(5+(10*2)+(15/3))*2+(-10)=50$になります。
上記例の２つの記述は同じ演算になりますが、`もの`を使うことにより読みやすくなります。

#### `および`、`か`、`こと`（Non Operation Code)

他に作用せず、なにもしません。読みやすい様に記述を補助するために使います。

_例：_

```
(1) １、および、２、３、４で関数【入力が、aとbとcとd。aとbとcとdを足す】を実行する。(10)
(2) 二倍とは、関数であって、入力がxで、xに2を掛けること。
```

注：助詞`とは`は`は`と同じです。

### 述語の再定義・多重定義(拡張)

#### 予約語の再定義

[予約語](#予約語keyword)は、`『』`(二重かぎ括弧)を使って、[識別子](#識別子identifier)として定義することが可能です。(以降は、`『』`無しでも識別子として扱われる。)

_例：_

```
『関数』は、１。関数を表示。(1が表示される。)
```

注：再定義は、ローカル([識別子の有効範囲](#識別子の有効範囲scope)参照)で有効。解除するには[識別子を削除](#削除remove)(形式６)します。

#### 再定義可能な予約語

予約語のうち以下は、再定義が可能です。

「
`足す`、`引く`、`掛ける`、`割る`、`負数`、`正`、`負`、`無`、  
`等しい`、`小さい`、`大きい`、`ある`、`ない`、  
`表示`、`改行`、`読む`、`尋ねる`、  
`追加`、`削除`、`繰り返す`、`写像`、`まとめる`、`絞り込む`、`並び替える`、`含む`、`逆順`、  
`返す`、`返る`、`実行`、`する`、`中止`、`継続`、
`入力`、`積む`、`捨てる`、`得る`、`写す`、`代入`、`入れ替える`、`生成`、`設定`、  
`もの`、`こと`、`ファイル一覧`、`識別子一覧`、`利用可能`、`初期化`
」

元の(再定義されていない)予約語を使用する場合は、以下の様に指定します。

```
形式：予約語「<元の予約語>」
```

例：

```
座標は、型であって、【
    初期化は、【入力がxとy】。
    『足す』は、算出【入力がp「座標に」で、
        xに、pのxを予約語「足す」て、代入。
        yに、pのyを予約語「足す」て、代入。
        自身を返す。
    】。
    「x」と「y」と「足す」は利用可能。
】
Aは、座標【xは-1。yは5】。
Bは、座標【xは2。yは3】。

(1) Aに、Bを足し、「結果」に代入。配列【結果のx、結果のy】(配列【1,8】)
(2) １を、２に足す。(3)
(3) 「い」を、「ろ」と足す。(「いろ」)
```

『足す』は、`座標`型のインスタンスメソッド(`算出`)として再定義しています。  
「座標」型の定義内(有効範囲内)で、元の足し算をするには、`予約語「足す」`を使います。  
(注：この場合、`予約語「足し」`の様に「足す」を連用形にすることはできません。)

(1)では、座標 A に座標 B を足すことで、『足す』の定義により B 自身の値が返るため、`結果`の配列が得られます。  
(2)(3)は、メソッド『足す』の有効範囲外のため、元の述語`足す`が実行されています。

#### 予約語の多重定義(拡張)

「再定義可能な予約語」を副詞`さらに`を使って定義することにより、予約語を[多重定義](#関数の多重定義function-overloading)(拡張)することができます。

```
形式：『<再定義可能な予約語>』は、さらに、<関数定義>
```

この場合、呼び出す引数に対し、すべての拡張した定義が一致しない場合は、元の予約語が呼び出されます。

_例：_

```
座標は、型であって、【
    初期化は、【入力がxとy】。
    「x」と「y」は利用可能。
】
Aは、座標【xは-1。yは5】。
Bは、座標【xは2。yは3】。

『引く』は、さらに、算出であって、【入力が、a「座標から」とb「座標を」で、
    xは0。yは0。
    aのxから、bのxを予約語「引く」、xに代入。
    aのyから、bのyを予約語「引く」、yに代入。
    xとyで座標を生成し、返す。
】。

(1) Aから、Bを引き、「結果」に代入。配列【結果のx、結果のy】。(配列【-3,2】)
(2) １を、２から引く。(1)
```

『引く』は、座標 a から座標 b を引く`算出`として、多重定義されています。算出内の数値の引き算には元の`予約語「引く」`を使います。

(1)では、当定義により、座標 A から座標 B を引いた値が、座標として返り、結果の配列が得られます。  
(2)では、「引く」は拡張定義されていますが、座標どうしの引き算でないため、既定の述語`引く`が実行されます。

## 糖衣構文(Syntax Sugar)

述語による記述は、わかりやすい一方、冗長になることがあります。  
記述を簡潔にできる様、以下の様な記述形式(糖衣構文)を用意しています。

### 呼び出し式 (Call Expression)

呼び出し式を使うことにより、「関数定義」を持つ関数、算出、およびインスタンスの初期化に対し、識別子名を指定した引数を渡し、呼び出すことができます。

```
形式：<式>【(引数が、)<(複数の)定義文>】
```

<式>は、`関数`、`算出`、`型`の型を持つオブジェクト、すなわち<識別子>または<リテラル>です。  
これに、ブロック`【】`で囲まれた複数の<[定義文](#定義文define-statement)>を続けて記述します。

注１：通常のブロックと異なり、一行で記述できる場合でも、`【】`は省略できません。  
注２：`引数が、`は省略可能です。

<定義文>は、関数等の入力識別子に渡す値(引数)を定義します。関数等は、スタックからではなく、これらの値を入力として、実行されます。

注３：スタックによる引数渡しと、呼び出し式による引数渡しは混在できません。  
注４：入力がない場合、定義文無しで、`【】`を記述します。  
注５：定義文ではなく、識別子を指定せず引数だけを渡すことはできません。

<定義文>の形式は、以下のとおり[既出のもの](#定義文define-statement)と同じです。

```
形式：<識別子>は、<定義内容>。
```

<定義内容>としては、同じく、リテラル、識別子、式等が使用できます。  
また、<識別子>の定義順序は、任意であり、関数等の入力定義順序と一致する必要がありません。

呼び出し式により、引数を渡す識別子を明示できるため、可読性が上げることができます。  
また、引数が多い場合や、順序が重要でない場合、[スタックによる引数渡し](#スタックによる引数渡し)に比べ、記述性が向上することがあります。  
既存プログラミング言語では、この様な引数の形式を「キーワード引数(keyword argumant)」と呼んでいます。

#### 関数の呼び出し式

`関数`は、呼び出し式により、述語`実行`または`する`を省略できます。

_関数呼び出しの例：_

```
加算は、関数【入力がaとbで、aにbを足す】。
(1) 1と2を加算する。(3)
(2) 加算【aは1。bは2】。(3)

(3) 5で関数【入力がxで、x】を実行する。(5)
(4) 関数【入力がxで、x】【xは5】。(5)
```

(1)と(3)はスタックによる実行、(2)と(4)は呼び出し式による実行です。  
呼び出し式により、(2)は識別子`加算`を、(4)は`関数`リテラルを、それぞれ実行しています。

#### 算出の呼び出し式

`算出`は、呼び出し式により、`取得`処理が呼び出されます。  
`設定`処理は、呼び出し式による呼び出しはできません。

_算出の呼び出し式の例：_

```
税込は、算出であって、入力が金額。金額を10で割って、金額を足す。
(1) 100円の税込。(110)
(2) 税込【金額は100円】。(110)
```

#### 型の呼び出し式

インスタンスを生成する際に、`型`の呼び出し式により、述語`生成`を省略できます。  
呼び出し式により、インスタンスを生成し、引数による初期化を行うことができます。

_型の呼び出し式の例：_

```
座標は、型【
  初期化は、【入力がxとy】。
  「x」と「y」は利用可能。
】
(1) 原点は、0と0で、座標から生成する。
(2) 原点は、座標【xは0。yは0】。
```

#### 呼び出し式の入力チェック

呼び出し式による実行時、スタックによる引数渡しと同様に関数等の[入力チェック](#入力チェック)が行われます。  
ただし、<型>のチェックは行いますが、入力で<格>が指定されていても、呼び出し式では<格>のチェックは行いません。  
また、スタックによる引数渡しとは異なり、全部の引数が、入力識別子名と一致しているかをチェックします。(定義順序はチェックしません。)

さらに、`…`(三点リーダ)による可変長の引数渡しも可能です([次項参照](#呼び出し式における可変長引数))。  
この場合、対象の入力識別子識別子に指定された<型>ではなく、引数の値が`配列`型であるかをチェックします。

_入力チェックの例：_

```
(1)
加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足し、返す】。
加算【aは「a」。bは「b」】。(エラー：入力の型が異なる。入力の型：文字列)
(2)
加算は、関数【入力がa「数値…」で、aを0と関数【入力が初期値と値で、初期値に値を足す】でまとめ、返す】。
加算【引数が、aは1】。(エラー：可変長識別子の値が配列ではない。型：数値)
```

(1)では、「数値」の指定に対し、「文字列」を渡しているためエラーとなります。  
(2)では、可変長の入力識別子`a`に対し、「数値」(`1`)を渡しているためエラーとなります。(配列の要素が「数値」であるかはチェックしない。)

#### 呼び出し式における可変長引数

スタックによる入力では、可変長引数は、`１と２と３と４と５で`の様に複数の句を渡しますが、呼び出し式の場合、`配列`で明示的に引数を渡します。

_可変長引数の例：_

```
加算は、関数【入力がa「数値」とb「数値…」で、aと、bを0と関数【入力が初期値と値で、初期値に値を足す】でまとめたものを足し、返す】。
(1) 1と2と3と4と5で、加算する。(15)
(2) 加算【aは1。bは配列【2と3と4と5】】。(15)
```

#### 呼び出し式と既定値

既定値を持つ入力識別子がある場合、呼び出し式での定義を省略できます。

_既定値入力の例：_

```
甲は、関数【入力が、xと、yは1と、zは2。xとyとzを足す】。
(1) 甲【xは1。yは2。zは3】。(6)
(2) 甲【xは1。yは2】。(5)
(3) 甲【xは1】。(4)
(4) 甲【】。(エラー：入力の数が足りていない。必要数：1)
```

入力識別子`y`と`z`は、既定値を持つため省略可能です。((2),(3))  
既定値を持たない入力識別子`x`を省略すると、エラーになります。(4)

#### 呼び出し式と多重定義

[呼び出し式の入力チェック](#呼び出し式の入力チェック)に従い、以下の様に、多重定義の中から、引数と入力が一致する関数定義を呼び出します。

1. 引数の定義文を評価し、識別子と値の辞書を作成します。
1. 多重定義から、候補となる可変長定義配列と、引数の数を持つ固定長定義配列(注)を抽出します。
1. 両候補で、以下のチェックを行い、一致する関数定義を抽出します。
   1. 定義配列を逆順(最新定義順)に、それぞれ全引数をチェック
   1. 同名の入力識別子が、可変長である場合、値の型が配列であるかチェック
   1. 同名の入力識別子が、固定長である場合、値の型が入力の型と一致するかチェック
   1. 全引数の型が一致すれば、当該定義を、対象の関数定義とします。
1. 対象が決定したら、残りの入力識別子に既定値を割り当てます。
1. 対象の関数定義を呼び出します。

注：[関数定義時の辞書](#多重定義における入力チェック処理)により、引数の数に応じた関数定義配列を取り出すことが可能

_多重定義での呼び出し式の例１：_

```
甲は、型であって、【
    初期化は、【aは１。bは2。】
    初期化は、さらに、【入力がaで、bは3。】
    初期化は、さらに、【入力がaとb】
    「a」と「b」は利用可能。
】
(1) 乙は、甲【】。乙のaと乙のbを足す(3)
(2) 乙は、甲【aは2】。乙のaと乙のbを足す(5)
(3) 乙は、甲【aは3。bは4】。乙のaと乙のbを足す(7)
```

(1)〜(3)は、インスタンスを生成し、引数定義に対応する甲の初期化を(上から順に)呼び出しています。

_多重定義での呼び出し式の例 2：_

```
(a) 加算は、関数【入力がa「文字列と…」とb「文字列を」で、aの最初にbを足し、返す】。
(b) 加算は、さらに、関数【入力がa「数値に」とb「数値を」で、aにbを足し、返す】。
(c) 加算は、さらに、関数【入力がa「文字列を」とb「文字列に」で、bにaを足し、返す】。

(1) 加算【aは5。bは5】。(10)
(2) 加算【aは「あ」。bは「い」】。(「いあ」)
(3) 加算【aは配列【「あ」、「か」】。bは「い」】。(「あい」)
```

多重定義関数`加算`(a)〜(c)に対し、それぞれ、  
(1)は、数値の入力識別子を持つ(b)の定義を呼び出し、結果 10 を得ています。  
(2)は、文字列の入力識別子を持つ(c)の定義を呼び出し、結果「いあ」を得ています。  
(3)は、可変長の識別子を持つ(a)の定義を呼び出し、結果「あい」を得ています。

### 代入文(Assignment Statement) - オブジェクトの要素への代入/設定

配列や辞書に値を代入するためには、述語`代入`(assign)を使い、`arrayの位置1に、3を代入する`の様に記述し、オブジェクトの要素に値を代入します。([配列への代入](#配列に代入)、[辞書への代入](#辞書に代入)を参照)  
また、型やインスタンスの要素に値を設定するためには、述語`設定`(set)を使い、`インスタンスの要素「メンバ」に値を設定する`の様に記述し、要素に値を設定します。([設定(Set)参照](#設定set))

これらに対し、以下の様な形式の構文(**代入文**)を用いることにより、これらを代替し、簡易に記述することができます。  
代入文では、`代入`や`設定`、`位置`、`要素`といった予約語の使用が不要になります。

```
形式：<オブジェクト>の<要素>は、<値>。
```

<オブジェクト>は、上記の様に、配列、辞書、型、インスタンスで、これらのリテラルおよび識別子になります。  
<要素>は、これらの位置、キー、メンバを表すオブジェクトです。  
<値>は、[定義文](#定義文define-statement)の<定義内容>と同じで、設定する値になる式や値を記述します。

この構文により、述語の`代入`/`設定`と同様に、<要素>に<値>を代入したオブジェクトが返ります。

そして、<オブジェクト>が識別子で、辞書にある場合は、結果のオブジェクトが辞書に登録されます。  
また、識別子が、ローカルに無く外側の辞書（関数の呼び元等）にある場合、結果のオブジェクトは、外側の辞書に登録されます。  

注：  
外側とローカル辞書の両方に同じ識別子がある場合、代入結果は、ローカル辞書に登録されます。外側の識別子を指定するためには、[`外部`](#外部outer)を使用します。

_配列への代入の例：_

```
(1) 配列【１、２、３】の１番目は、５。(配列【１、５、３】)
(2) 甲は、配列【１、２、３】。乙は０。甲の乙は、５。甲の最初。(5)
```

(1)では、配列リテラルの１番目に５を代入した結果が、配列として返ります。  
(2)では、配列「甲」の乙番目(0)に５を代入した結果が、甲に代入されます。甲の「最初」は 5 に変更されています。  

注: `甲の最初は、５`の様な書き方はできません。

_辞書への代入の例：_

```
(1) 辞書【1が「一」、2が「二」、3が「三」】の2は「弍」。得たものの2の値。(弍)
(2) 辞書【1が「一」、2が「二」、3が「三」】の4は「四」。得たものの4の値。(四)
(3) 甲は、辞書【「い」が「一」、「ろ」が「二」、「は」が「三」】。甲の「は」は「参」。
(4) 甲は、辞書【真が1、偽が0】。甲の偽は、2。甲の偽の値。(2)
```

(1)では、辞書リテラルのキー2に「弍」を代入した結果が、オブジェクトとして返ります(スタックに格納される)。  
(2)では、辞書リテラルにはキー4が無いため、キー4、値「四」の要素が追加されたオブジェクトが返ります。  
(3)では、キー「は」の値が「三」から「参」に変更されたオブジェクト「甲」が辞書が格納されています。  
(4)では、キー「偽」の値が 0 から 2 に変更されたオブジェクト「甲」が辞書が格納されています。

_関数の呼び元への代入の例：_

```
(1) 甲は、配列【１、２、３】。関数【甲の２は、5。】を実行する。甲の最後。(5)
(2) 甲は、辞書【1が「一」、2が「二」、3が「三」】。乙は２。関数【甲の乙は「弍」。】を実行する。甲の2の値。(弍)
```

それぞれ、関数内の代入文で、呼び元の「甲」に代入結果が上書きされます。

_型の要素への設定の例：_

```
挨拶は、型であって、【
    型の要素が、【宛名は、「田中」。本文は、算出【「こんにちは、」と宛名と「さん。」を足す】】。
】。
(1) 挨拶の本文。(こんにちは、田中さん。)
(2) 挨拶の要素「宛名」に、「鈴木」を設定する。挨拶の本文。(こんにちは、鈴木さん。)
(3) 挨拶の宛名は「高橋」。挨拶の本文。(こんにちは、高橋さん。)
```

型の要素「宛名」に値を設定する例です。  
(1)は設定前の算出「本文」の結果で、(2)(3)の様に値を「宛名」に設定することより、「本文」が変わります。  
(2)では`設定`、(3)では`代入文`で値を設定しています。

_インスタンスの要素への設定の例：_

```
温度は、型であって、【
    摂氏は、0。
    華氏は、算出【
        設定が、【入力が設定値。設定値から３２を引いたものに５を掛け、９で割り、摂氏に代入する。】
        取得が、【９に摂氏を掛け５で割ったものに、３２を足す。】
    】。
    「摂氏」と「華氏」は利用可能。
】。
気温は、温度から生成する。

(1) 気温の要素「摂氏」に20度を設定する。気温の華氏。(68)
(2) 気温の華氏は、32度。気温の摂氏。(0)
```

インスタンスの要素「摂氏」と「華氏」に値を設定する例です。  
型「温度」を定義し、インスタンス「気温」を生成しています。  
「摂氏」は数値メンバ、「華氏」は算出メンバで、「華氏」の設定と取得により、「摂氏」との変換を行います。  
(1)では、「摂氏」に 20 度が設定され、「華氏」の取得により、68 度に変換されています。  
(2)では、32 度が「華氏」の設定の入力値となり、変換されて「摂氏」に上書きされます。  
どちらも同じ`設定`の動作をします。

-以上-
