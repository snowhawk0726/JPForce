# 文法

ふぉーす(JpForce)の文法を、形式(構文)と例(サンプル)を中心に説明します。  
文中の用語には、参考として、対応するプログラミング用語等の英単語をかっこ内に表記しています。  
また、使用例(サンプルコード)には、実行・評価結果や内容を説明するコメント(ふぉーす形式の)を付記しています。

## プログラムの構成要素

### 文(Statement)

文は、述語とその他の成分から成り立っており、プログラムを構成する基本要素です。  
文には構成要素として、予約語、助詞、識別子、数値、記号が含まれます。  
プログラムは、この構成要素を順に解釈し評価することにより、実行されます。  
ふぉーすでは、文の終わりを、句点`。`、改行`\n`、ブロックの終わり`】`、ファイルの終わり`EOF`で判断します。

### 式(Expression)

式は、文中で述語とその引数(目的語や補語等)により値を出力するものを言い、文を構成します。  
(ふぉーすでは、他のプログラム言語における記号を用いた式(例えば`a=b*2`等)は扱っていません。)  
出力する値により、数値 → 算術式、文字列 → 文字式、真偽値 → 条件式または論理式、などと呼んでいます。

_式の例：_

```
aがbより大きい。(真偽値を出力 → 条件式)
１と２を足す。(数値(３)を出力 → 算術式)
「あ」と「い」を足す。(文字列「あい」を出力 → 文字式)
```

注： 上記はいずれも複数の式から成り立っています。ふぉーすにおいて、引数`aが`や述語`大きい`等が１つの式となります。

### 値(Literal)とオブジェクト(Object)

プログラムに書かれる１や「いろは」などの値を表現する書式を「リテラル(literal)」と言います。  
リテラルは、コンピュータ内で解析・評価されて「オブジェクト(object)」というデータとして扱われます。  
また、オブジェクトは、その振る舞いを決める型を持ちます。  
ふぉーすでは、単純な値を表す、`数値`、`文字列`、`真偽値`、`無`、集合を表す、`配列`、`辞書`、`列挙`、また、処理を表す`関数`、`算出`、そして定義可能な型を表す`型`などがあります。これらは、定義文により、識別子に関連付けることが可能です。ふぉーすでは、定義された識別子とオブジェクトの辞書を持ち、これを用いてプログラムを実行します。

オブジェクトに対しては、以下のような述語を使用可能です。

```
形式：<オブジェクト>の型 (オブジェクトの型を文字列で返す)
形式：<オブジェクト>の数値 (オブジェクトの値を数値で返す)
形式：<オブジェクト>の文字列 (オブジェクトの値を文字列で返す)
形式：<オブジェクト>の名前 (オブジェクトの識別子名を文字列で返す)
形式：<オブジェクト>の数 (オブジェクトの要素数を数値で返す)
形式：<オブジェクト>が空 (オブジェクトの要素が空であるか判定する)
形式：<オブジェクト>が真(または偽) (オブジェクトの真偽を判定する)
形式：<オブジェクト>が無 (オブジェクトが無の場合、真を返す)
形式：<オブジェクト１>(が)<オブジェクト２>(に)等しい。(値が等しい場合、真を返す)
```

オブジェクトの属性を得る場合には、`<オブジェクト>の<述語>`の様に助詞`の`を用い、オブジェクトの評価・判定を行う場合には、`<オブジェクト>が<述語>`の様に助詞`が`を用います。

_オブジェクトに対する述語の例：_

```
「こんにちは」の型。(「文字列」)
aは1。aの型。(「数値」)
aの文字列。(無)
bは、配列【1, 2, 3】。bの数。(3)
bが空。(偽)
aがbに等しくない。(真)
```

### 予約語(Keyword)

予約語には、以下があります。

1. 主に定義文で使用する「`配列`、`辞書`、`列挙`、`範囲`、`関数`、`型`、`規約`、`算出`」
1. 値(literal)として使用する「`真`、`偽`、`無`」
1. 制御文で使用する「`場合`、`反復`、`間`」
1. 述語(名詞、動詞、形容詞）として使用する「`足す`、`引く`、`掛ける`、`割る`、`等しい`、`小さい`、`大きい`、`ある`、`ない`、`もの`、`正`、`負`、`返す`、`実行`、`する`、`追加`、`削除`、`繰り返す`、`中止`、`写像`、`まとめる`、`絞り込む`、`並び替える`、`含む`、`入力`、`積む`、`捨てる`、`得る`、`写す`、`空`、`代入`、`入れ替える`、`表示`、`改行`、`読む`、`生成`、`上書き`、`設定`、`かつ`、`または`、`および`、`こと`、`か`、`よって`、`逆順`、`ファイル`、`ファイル一覧`、`識別子`、`識別子一覧`、`位置`、`要素`、`利用可能`、`初期化`」

### 助詞(Particle)

助詞（以下）は、文の中で区切り文字として扱います。

「`は`、`が`、`を`、`に`、`で`、`と`、`へ`、`から`、`より`、`まで`、`の`、`だ`、`た`、`とは`、`では`」

助詞は、引数として値と共に述語に渡され、述語側で妥当性をチェックすることが可能です。([句](<#句(Phrase)>)を参照)

_助詞の例：_

```
100から10を引く。10を100から引く。
※ 助詞「から」と「を」を関数側でチェックすることにより、どちらの形式でも90という結果になります。
```

#### 特殊な助詞

また、特殊な助詞として、個数を表す`個`も同様に助詞として扱います。([数値の単位](#数値の単位)参照)  
さらに、範囲、比較を表す`以上`、`以下`、`未満`も助詞として扱います。([範囲](#範囲range)、[数値の比較](#数値の比較演算判定)参照)

### 識別子(Identifier)

定義する語(述語)を表現します。

識別子は、文字、数字、記号を含む語で表し、名詞、動詞、形容詞などの述語として使用されます。

識別子に使用する語として、

1. 助詞を含む語
1. 記号(注)を含む語
1. 数値で始まる語
1. 予約語「する」「し」「こと」「また」「場合」で終わる語

は使えません。

ただし、`『』`(二重かぎ括弧)で囲うことにより、明示的に識別子として使用することができます。  
(注：ここで言う記号は、[以下にある記号](#記号symbol)です。それ以外の記号は識別子として使用可能です。)

_識別子の例：_

```
aは1。aを表示。(1)
『割った余り』は、算出であって、入力がa「数値」とb「数値」であり、本体が、aをbで割り、bを掛け、aから引いたものを返す。
「19を４で割った余りは、\改行なし」と、19を4で『割った余り』を表示する。
※ 19を４で割った余りは、3
```

注：『割った余り』は、助詞`た`を含むため、(暗黙の)識別子とすることができません。

### 記号(Symbol)

プログラムを記述するために使用する記号は以下のとおりです。半角文字と同じ全角文字は使用可能です。
(これら以外は、基本的に識別子として使用可能です。)

- ブロック(`【】`)  
  墨付き括弧`【】`で括られた複数の文を、制御文や、関数等の定義において、ひとまとまりの「ブロック」として扱います。  
  ブロックの始まり`【`から終わり`】`までを行末までの一行で記述できる場合、`【】`は省略できます。
- 句読点( `、` `。`)  
  句点`。`は、文の終わりに記述します。句点の後は、新たな文として解釈されます。行末やブロックの前の句点は基本省略可能です。
  読点`、`は、文を読みやすい様に、区切る記号です。
- コメント(`※` `()`)  
  コメントは、プログラム内で、意図や使用方法を読み手に伝えるもので、２通りの記述方法が可能です。
  1.  `（`(丸括弧)で始まり、`）`(丸括弧閉じ)で終わる括弧内をコメントとする。
  1.  `※`(米印)または`*`(アスタリスク)で始まり、行末までをコメントとする。
- タブ(`\t`)、空白(` `)、改行(`\n`)  
  タブや空白は、区切り文字として扱いますが、機能はせず読み飛ばします。プログラムの構造を分かりやすくする様に、使用します。
- 文字列（`「」`)  
  かぎ括弧`「」`で括られた文字列を、プログラム内で識別子に割り当てたり、引数とするための文字列（String Literal)として扱います。
- 識別子（`『』`)  
  二重かぎ括弧`『』`で括られた文字列を、プログラム内で明示的な識別子として扱います。
- エスケープ文字(`\\`)  
  述語`表示`で使用します。文字列中の記号を有効にしたり、表示の制御をしたりするために用います。
- 中黒(`・`)  
  `列挙`で識別子をアクセスするために使用します。([列挙要素のアクセス](#列挙要素のアクセス)を参照)
- 三点リーダ(`…`)  
  関数の入力チェックで、前にある格を持つ引数の数が可変であることを意味します。([入力チェック](#入力チェック)を参照)

### 連用形(語尾変化)

語尾が変化する予約語および識別子(動詞、形容詞)は、連用形での使用が可能です。

連用形は、以下のような語尾および語の辞書を持ち、辞書を使って一致する述語を特定します。これにより、動詞や形容詞の語尾変化に対応しています。

1. 語尾の辞書(連用形 → 終止形)  
   “い”→”う”, "え”→”える", "き”→”く", "ぎ”→”ぐ", "く”→”い", "け”→”ける", "し”→”す", "せ”→”せる", "ち”→”つ", "っ”→”る", "て”→”てる", "に”→”ぬ", "ね”→”ねる", "び”→”ぶ", "み”→”む", "り”→”る", "れ”→”れる", "ん”→”む"
1. 語の辞書(連用形 → 終止形)  
   "し”→”する", "て”→”た", "で”→”だ", "得”→”得る", "見”→”見る", "引い”→”引く",
1. 語の辞書(未然形 → 終止形)  
   "含ま”→”含む"

注： 辞書には、連用形だけでなく未然形の語尾も含みます。これは、述語`ない`が未然形に付くため、その対応です。

_連用形の例：_

```
100は10より大きく、かつ、10は100より小さい。(真)
2と3を足し、10から引く。(5)
```

`大きく`は、`大きい`、`足し`は`足す`の連用形になります。

### スタックによる引数渡し

式の評価時、引数(句や値など)となるオブジェクトは、スタックに格納されます。述語は、これらのオブジェクトをスタックから取り出し、処理を行った結果(オブジェクト)をスタックに出力します。  
これにより、複数の式を続けて記述することにより、スタックを介した連続したデータ処理を、簡潔に表現できます。

_例：_

```
10と2を掛け、15で割り、2を掛け、-10を足す。(-8)
```

例の様に、`掛ける`、`割る`、`足す`を使った式を続けて記述することで、スタックを介して連続したデータ処理が可能です。

### 句(Phrase)

文中の値や識別子と助詞(注)を組み合わせたものを、「句」と呼び、オブジェクトとして扱います。句は、引数として関数等に渡されます。また、句の中の助詞を「格」と呼びます。  
関数等に渡された引数は、関数内で句から値を取り出したものを入力識別子に代入するため、通常は、句から格を取り出すことはできません。(詳細は[`関数`](#関数function)を参照)

ただし、述語`得る`を使うことにより、スタックにある句から、値や格を直接取り出すことは可能です。(詳細は[`積む`(Push)と`得る`(Pull)と`写す`(Duplicate)](#積むpushと得るpullと写すduplicate)を参照)  
この場合、以下のように、値や格を取り出すことができます。

```
形式：<句>の値 (値を取り出す)
形式：<句>の格 (格を取り出す)
```

句以外のオブジェクトに対して、これらを適用した場合、「<オブジェクト>の値」はオブジェクトそのものが返り、「オブジェクト>の格」は`無`が返ります。  
また、句は、オブジェクトなので、[オブジェクトに対する述語](<#値(Literal)とオブジェクト(Object)>)が使用可能です。

### 識別子の有効範囲(Scope)

識別子は、紐づけられたオブジェクトと共に辞書に格納されます。この辞書は、通常の(グローバルな)ものとは別に、`型`(および、そのインスタンス)、`列挙`、`関数`、`算出`ごとに個別に（ローカルに）存在します。  
辞書は、それぞれ範囲内で有効であり、識別子は、その範囲内でユニークなものとなります。  
有効範囲内で、同一の識別子に値を代入したり、定義をすることはできますが、同じ識別子に、再代入・再定義した場合は、既存の定義や値は上書きされます。

ただし、呼び出された関数や、生成されたオブジェクトから、呼び元（呼び出し元、または生成元)の識別子を参照することが可能です。([クロージャ](#クロージャclosure)参照)  
呼び元の識別子と同じ名前の識別子を定義した場合、ローカルの辞書に登録されます。また、呼び元の識別子は参照可能ですが、定義・変更することはできません。変更するためには、述語`上書き`を使います。

## 値(Literal)と型(Type)

ふぉーすでは、オブジェクトの型として、`数値`,`文字列`,`真偽値`,`無`,`配列`,`辞書`,`範囲`,`列挙`,`関数`,`型`,`規約`,`算出`があります。
`数値`,`文字列`,`真偽値`,`無`以外の型では、以下の様な形式で定義することが可能です。

```
形式１：<型名>であって、<型の定義>
形式２：<型名>であり、<型の定義>
形式３：<型名>で、<型の定義>
形式４：<型名>、【<型の定義>】
形式５：<型名>【<型の定義>】
```

形式１から形式３(ブロック記号`【】`無し)は、一行(行末まで)で定義が完了する場合に限ります。  
以降の個々の型の説明では、形式２から形式４のバリエーションはについて、構文形式の記載を省略します。

なお、述語`関数`および`算出`については、関数を、`型`および`規約`については、型および規約を参照してください。

### 数値(Number)

整数(`0`から`9`および`ー`(マイナス)）を数値として扱います。全角半角は区別しません。

#### 数値の単位

数値に続く文字列は、理解を助けるための数値の単位として記述できます。この単位は、解析時に無視されるため、<数値><単位>は、単に<数値>という記述と同じになります。

_例：_

```
鳥は2羽。犬は1匹。鳥と犬を表示する。(2と1が数値として表示される。)
配列【１、２、３】の１番目。(2)
```

ただし、`個`は単位ではなく「助詞」であり、無視されずに述語に`10個`の様に渡されます。  
例えば、3 個の要素`3`をもつ配列を作る場合、以下の様に助詞`個`を使用します。([配列](#配列の要素定義初期化)参照)

_例：_

```
甲は、配列【要素が、３個の３】。甲。(配列であって、【要素が、3と、3と、3】)
```

#### 数値の算術演算

数値を算術演算する(数値を返す)述語には以下があります。

- `足す`(Add)
- `掛ける`(Multiply)  
  述語`足す`と`掛ける`は、２つ以上の数値のオブジェクトをそれぞれ、加算、乗算します。２つは、同じ構文形式です。

```
形式１：<数値１>(と)<数値２>(を)足す(または掛ける)。
形式２：<数値１>と<数値２>と<数値３>…(を)足す(または掛ける)。
```

注：形式２の場合、<数値１>、<数値２>に続く助詞は`と`が必須で、それ以外の助詞では、足す(掛ける)ことができません。形式１の２つの助詞、および、形式２の最後の助詞は任意です。

_例：_

```
1と2を足す。(3)
2に3を掛ける。(6)
3に4を掛け、5を足す。(17)
1と2と3を掛ける。(6)
1に2と3を掛けたものを足す。(7)
```

最後の例では、1 の助詞が、`と`ではなく`に`であるため、1 と 2 は掛けられません。

- `引く`(Subtract)  
  `引く`は、助詞`から`の句の数値から、助詞`を`の句の数値を引きます。

```
形式１：<数値１>(から)<数値２>を引く。
形式２：<数値１>(を)<数値２>から引く。
```

オブジェクトが助詞を持つ句でなくても、引く数値、引かれる数値を判断し、演算します。

_例：_

```
(1) 5から3を引く。(2)
(2) 1と2を足し、5から引く。(2)
(3) 5から、1と2を足したものを引く。(2)
```

(3)では、まず、５をスタックに格納し、さらに１と２を足した結果(3)をスタックに格納します。そして「引く」で、２つをスタックから取り出し、引きます。

- `割る`(Divide)

```　　
形式１：<数値１>(を)<数値２>で割る。
形式２：<数値１>(で)<数値２>を割る。
```

_例：_

```
５を３で割る。(1)
５で、1と9を足したものを割る。(2)
```

- `負数`(Negate)  
  引数の数値の符号を反転し(-1 を掛ける)、値を返します。

```
形式１：<数値>を負数にする。
形式２：<数値>の負数。
```

_例：_

```
10を負数にする。(-10)
aは-1。aの負数。(1)
```

#### 数値の比較演算/判定

- 比較演算  
  数値を比較する(真偽値を返す)述語には以下の様なものがあります。

```
形式：<数値１>(が)<数値２>(より)小さい。
形式：<数値１>(が)<数値２>(より)大きい。
形式：<数値１>(が)<数値２>以上である。
形式：<数値１>(が)<数値２>以下である。
形式：<数値１>(が)<数値２>未満である。
形式：<数値１>(が)<数値２>(に)等しい。
```

かっこで囲われている助詞は種類、有無を問いません。  
`以上`、`以下`、`未満`で比較する場合、上記の通り、肯定`である`、または否定`でない`を付ける必要があります。

_例：_

```
1は2より小さい。(真)
1が1以上である。(真)
1は1未満である。(偽)
1が2に等しくない。(真)
1は1以下でない。(偽)
```

- 数値の判定  
  述語`正`(positive),`負`(negative)は、数値の正負を判定します。

```
形式：<数値>が正(または負)。
```

_例：_

```
xは-1。xが負。(真)
0が正、または、0が負。(偽：0は正でも負でもない)
```

#### 数値の文字化(Cast)

数値を半角の文字列に変換します。

```
形式：<数値>の文字列。
```

_例：_

```
１５の文字列。(「15」)
xは-1。xの文字列。(「-1」)
```

### 文字列（String)

かぎ括弧`「」`で括られた文字列を、プログラム内で文字列として扱います。

#### 文字列の操作/判定

文字列を操作する述語には以下があります。

- `数`(Count)

```
形式：<文字列>の数。(文字数を数値を返す)
```

_例：_

```
「あいう」の数。(3)
```

- `空`(Empty)

```
形式：<文字列>が空。(文字列が空(から)の場合、真を返す)
```

_例：_

```
aは「」。aが空。(真)
```

- `含む`(Contains)

```
形式：<文字列１>が<文字列２>を含む。(含む場合、真を返す)
```

_例：_

```
「かきくけこ」が「く」を含む。(真)
「なにぬねの」が「くけ」を含まない。(真)
```

- `足す`(Add)  
  ２つ以上の文字列を結合します。

```
形式１：<文字列１>(と)<文字列２>(を)足す。
形式２：<文字列１>と<文字列２>と<文字列３>…(を)足す。
```

注：形式２で、複数の文字列を結合する場合、助詞が`と`である必要があります。それ以外の助詞は任意です。

_例：_

```
「あ」と「い」と「う」を足す。(「あいう」)
```

- `逆順にする`(Reverse)

```
形式：<文字列>を逆順にする。(<文字列>の語順を逆にした文字列を返す)
```

_例：_

```
「あいうえお」を逆順にする。(「おえういあ」)
```

#### 文字列の位置/範囲

文字列の位置や範囲を指定する述語には以下があります。

```
形式：<文字列>の<数値(位置)>。(文字列の指定位置にある文字を返す)
形式：<文字列>の先頭/最初。(文字列の先頭にある文字を返す)
形式：<文字列>の後尾/最後。(文字列の後尾にある文字を返す)
形式：<文字列>の残り。(先頭文字以外の文字列を返す)
形式：<文字列>の<範囲>。(指定範囲にある文字列を返す)
```

位置は、数値で、０から始まります。また、指定位置に文字が存在しない場合は、`無`が返ります。

_例：_

```
「あいうえお」の２番目。(「う」)
nは1。「あいうえお」のn(番目)。(「い」)
「あいうえお」の先頭。(「あ」)
「あいうえお」の後尾。(「お」)
「あいうえお」の残り。(「いうえお」)
「あいうえお」の範囲【1から3まで】。(「いうえ」)
「」の最初。(無)
```

#### 文字列の数値化(Cast)

文字列を数値に変換します。数値に変換できない場合は`無`を返します。

```
形式：<文字列>の数値。
```

_例：_

```
「−１」の数値。(-1)
xは真。xの数値。(無)
```

### 真偽値(Boolean)

値を`真`または`偽`で表し、条件式や論理演算の結果となります。

#### 真偽値の論理演算

論理演算の述語には以下があります。

- `ある`(Be)/`ない`(Not)  
  直前の論理式を肯定/否定します。

```
形式：<論理式>ある(<論理式>の結果を真偽値で返す)
形式：<論理式>ない(<論理式>の否定を真偽値で返す)
```

_例：_

```
文字列は「」。文字列が空である。(真)
1は2より小さくない。(偽)　
```

また、２つのオブジェクトが等しいか否かを判定するには、以下の形式で記述します。

```
形式： <オブジェクト１>が<オブジェクト２>である
形式： <オブジェクト１>は<オブジェクト２>である
形式： <オブジェクト１>が<オブジェクト２>でない
形式： <オブジェクト１>は<オブジェクト２>でない
形式： <オブジェクト１>が<オブジェクト２>ではない
形式： <オブジェクト１>は<オブジェクト２>ではない
形式： <オブジェクト１>(が)<オブジェクト２>(に)等しい
形式： <オブジェクト１>(が)<オブジェクト２>(に)等しくない
```

(注：述語`等しい`は引数の助詞を問いません。)

_例：_

```
1は2である。(偽)
1が2ではない。(真)
配列【１、２、３、４、５】は、配列【1,2,3,4,5】に等しくない。(偽)　
```

#### 真偽値の文字化(Cast)

真偽値を文字列に変換します。

```
形式：<真偽値>の文字列。
```

_例：_

```
真の文字列。(「真」)
１と２は等しいの文字列。(「偽」)
```

### 無(Null)

述語`無`は、値が無いことを示します。

_例：_

```
ハッシュ表は、配列【22, 1, 無, 無, 15, 無, 無, 無, 8, 無, 無】。ハッシュ表の最後。(無)
ハッシュ表の１０番目。(無。配列に１０番目の要素が無い。)
無は真である。(偽)
無は無である。(真)
無の文字列。(「無」)
```

[真偽値の論理演算](#真偽値の論理演算)にある述語`ある`と`ない`により、値があるか無いかを判定する以下の様な記述が可能です。

```
値は１。値がある場合、値を表示する。(1を表示)
値は無。値がある場合、値を表示する。(何も表示しない。)
値がない場合、「🈚️」を表示する。(🈚️を表示)
```

### 配列(Array)

順序を持った値の集合です。

```
形式１：配列【(要素が、)<(複数の)値>】
形式２：配列であって、(要素が、)<(複数の)値>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。  
また、値が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
各要素の型は問いません。

注：各値は、数値などのリテラル、および、オブジェクトを返す式(例： `1と２を足す`)で記述可能です。

_例：_

```
配列【6, 15, 4, 2, 8, 5, 11, 9, 7, 13】をクイックソートし、表示する。
※ 関数「クイックソート」で引数の配列をクイックソートし、コンソールに表示する

甲は、配列であって、要素が、１と、２に２を掛けたものと、３に３を足したもの。(甲は配列【1, 4, 6】)
```

#### 配列要素のアクセス

配列の要素を位置で索引する方法は、以下のとおりです。

```
形式：<配列>の<数値(位置)>。(配列の指定位置にある文字を返す)
形式：<配列>の先頭/最初。(配列の先頭にある文字を返す)
形式：<配列>の後尾/最後。(配列の後尾にある文字を返す)
形式：<配列>の残り。(配列の先頭要素以外の配列を返す)
形式：<配列>の<範囲>。(配列の指定範囲にある配列を返す)
```

位置は、数値で、０から始まります。また、指定位置に要素が存在しない場合は、`無`が返ります。

_配列要素のアクセスの例：_

```
配列【1,3,5,7】の1。(3)
数列は、配列【1, 4, 6】。数列の2番目。(6)
pは4番目。配列【1,3,5,7】のp。(無 →４番目に文字が無い)
配列【1,3,5,7】の先頭。(1)
配列【1,3,5,7】の残り。(配列【3,5,7】)
配列【1,3,5,7,9】の範囲【1から3まで】。(配列【3,5,7】)
配列【】の最初。(無)
```

また、述語`追加`(append)によって、配列に要素を付け加えることができます。

```
形式１：<配列>(に)<値>を追加する。
形式２：<値>(を)<配列>に追加する。
```

_`追加`の例：_

```
配列【１、２、３】に４を追加する。(配列【１、２、３、４】)
配列【１、２、３】に配列【４】を追加する。(配列【１、２、３、配列【４】】)
１と３を足し、配列【１、２、３】に追加する。(配列【１、２、３、４】)
```

さらに、述語`削除`(remove)によって、配列の指定位置にある要素を削除することが可能です。

```
形式：<配列>(から)<数値(位置)>を削除する。(配列の指定位置の要素を削除し、結果を返す）
形式：<配列>(から)「先頭」を削除する。(配列の先頭位置の要素を削除し、結果を返す）
形式：<配列>(から)「後尾」を削除する。(配列の後尾位置の要素を削除し、結果を返す）
形式：<配列>(から)「全て」を削除する。(配列の全ての要素を削除し、結果を返す）
```

_`削除`の例：_

```
配列【1, 2, 3】から、1番目を削除する。(配列【１、３】)
配列【1, 2, 3】から「先頭」を削除する。(配列【２、３】)
配列【1, 2, 3】から「全て」を削除したものの数。(0)
```

さらに、述語`代入`(assign)によって、配列の指定位置に指定オブジェクトを代入することが可能です。

```
形式１：<配列>の位置<数値>に<値>を代入する
形式２：<配列>の位置「<識別子>」に<値>を代入する
形式３：<値>を<配列>の位置<数値>に代入する
形式４：<値>を<配列>の位置「<識別子>」に代入する
```

注１：指定位置が配列外の場合、「エラー：指定位置が、配列内に無い。」  
注２：<配列>が<識別子>の場合、<値>を代入した結果は、さらに<識別子>に代入されます。また、<配列>がリテラルである場合、<値>を代入した結果が返ります。

_`代入`の例：_

```
配列【１、２、３】の位置１に５を代入する。(配列【１、５、３】が返る)
甲は、配列【１、２、３】。乙は０。甲の位置「乙」に５を代入する。(甲は配列、【５、２、３】)
```

#### 配列の操作/判定

文字列と同様に、以下の様な配列を操作/判定する述語があります。

```
形式：<配列１>(と)<配列２>(と<配列３>)を足す。
形式：<配列>を逆順にする。(配列の要素を逆順にした配列を返す)
形式：<配列>の数。(配列の要素数を数値で返す)
形式：<配列>が空。(配列が空(から)の場合、真を返す)
形式：<配列>が<値>を含む。(配列の要素にオブジェクトが含まれる場合、真を返す)
形式：<配列>が<範囲>を含む。(配列に範囲が含まれる要素(数値)がある場合、真を返す)
```

_例：_

```
配列【1,2,3】と配列【4,5,6】を足す。(配列【1,2,3,4,5,6】)
配列【1,2,3,4,5,6】を逆順にする。(配列【6,5,4,3,2,1】)
行列は、配列【1】。行列の数。(1)
行列が空。(偽)
配列【１、２、３、４、５】が3を含む。(真)
配列【１、２、３、４、５】が配列【１、３】を含む。(偽)
配列【１、２、３、４、配列【１、３】】が配列【１、３】を含む。(真)
配列【１、２、３、４、５】が範囲【６以上】を含む。(偽。６以上の要素が無い)
配列【範囲【１以上５未満】、範囲【６以上１０以下】、範囲【１１以上】】が５を含む。(偽)
```

#### 配列の要素定義(初期化)

空の配列を識別子に割り当てる場合、以下の様に記述可能です。

```
形式１：<識別子>は、配列【】
形式２：<識別子>は、配列であって、【】
形式３：<識別子>は、配列。
```

形式３の場合、句点「。」は必須です。

_例：_

```
行列は、配列。(行列は、配列【】と同じ。)
行列が空。(真)
```

また、以下の様に同一の要素を指定数個持った配列を定義することができます。

```
形式１：配列【(要素が、)<数値>個の<オブジェクト>】
形式２：配列であって、(要素が、)<数値>個の<オブジェクト>
```

_例：_

```
甲は、配列であって、要素が、３個の３。(甲は配列【3,3,3】と同じ。)
```

### 辞書(Dictionary)

要素(キーと値の組)の集合です。  
配列と異なり、要素には順序がありません。キーで索引し、値を得ることから辞書と呼びます。  
各キーは、辞書内でユニークな値です。

```
形式１：辞書【(要素が、)<(複数の)要素>】
形式２：辞書であって、(要素が、)<(複数の)要素>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。

要素の形式は、以下のとおりです。

```
形式：<キー>が<値>
```

また、要素が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
各値の型は問いませんが、キーは、`数値`、`文字列`、`真偽値`のいずれかになります。

注：キーおよび値は、数値などのリテラル、および、オブジェクトを返す式(例： `1と２を足す`)で記述可能です。

_例：_

```
辞書【「一」が0と1を足す、「二」が10から8を引く、「三」が15を5で割る】
（辞書【要素が、「一」が1と、「二」が2と、「三」が3】と同じ）
```

#### 辞書要素のアクセス

辞書をキーで索引する方法は、以下のとおりです。

```
形式：<辞書>の<キー>(の値)
```

辞書内の<キー>で索引し、値を取り出すことができます。  
<キー>が辞書に存在しない場合は、`無`が返ります。  
(注：「の値」は対象が「句」でないは、単に値をそのまま返します。「の値」は、読みやすい様に必要に応じて付記します。)

_要素アクセスの例：_

```
辞書【要素が、「一」が1と、「二」が2と、「三」が3】の「二」。(2)
漢数字表は、辞書【要素が、「一」が1と、「二」が2と、「三」が3】。漢数字表の「三」の値。(3)
漢数字表の「四」の値。(無)
辞書【真が０、偽が１】の偽の値。(1)
```

また、述語`追加`(append)によって、辞書に要素を付け加える、または要素を更新することができます。
<キー>が既存の場合、そのキーで、値を更新します。

```
形式１：<辞書>(に)<キー>が<値>を追加する。
形式２：<キー>が<値>(を)<辞書>に追加する。
形式３：<辞書１>(に)<辞書２>を追加する。
形式４：<辞書２>(を)<辞書１>に追加する。
```

_`追加`の例：_

```
辞書【「一」が１、「二」が２、「三」が３】に「四」が４を追加。
辞書【「一」が１、「二」が２、「三」が３】に辞書【「四」が４】を追加。
nは１と３を足したもの。「四」がnを辞書【「一」が１、「二」が２、「三」が３】に追加。
※ 結果はいずれも、辞書【「一」が１、「二」が２、「三」が３、「四」が４】
```

_`追加`(更新)の例：_

```
変換表は、辞書【「一」が１、「二」が２、「三」が３、「四」が４】。変換表の「四」の値。(4)
変換表に、「四」が無を追加して代入する。変換表の「四」の値。(無)
```

(注：結果の辞書要素の順は不定です。)

さらに、述語`削除`(remove)によって、辞書の指定位置にある要素を削除することが可能です。

```
形式１：<辞書>(から)<キー>を削除する。(辞書のキーの要素を削除し、結果を返す）
形式２：<キー>を<辞書>から削除する。(辞書の指定位置の要素を削除し、結果を返す）
形式３：<辞書>(から)「全て」を削除する。(配列の全ての要素を削除し、結果を返す）
```

_`削除`の例：_

```
辞書【「その一」が１、「その二」が２、「その三」が３】から、「その二」を削除する。
※ 結果：辞書【「その一」が１、「その三」が３】)
辞書【「その一」が１、「その二」が２、「その三」が３】から、「その２」を削除する。
※ キー「その２」は辞書に無いため、辞書【「その一」が１、「その二」が２、「その三」が３】が返る。
キーは「その一」。キーを辞書【「その一」が１、「その二」が２、「その三」が３】から削除する。
※ 結果：辞書【「その二」が２、「その三」が３】)
辞書【「その一」が１、「その二」が２、「その三」が３】から「全て」を削除したものが空。(真)
```

#### 辞書の操作/判定

以下の様な辞書を操作/判定する述語があります。

```
形式：<辞書１>(と)<辞書２>(が)等しい。(辞書の要素が全て等しい場合、真を返す)
形式：<辞書>の数。(辞書の要素数を数値で返す)
形式：<辞書>が空。(辞書が空(から)の場合、真を返す)
形式：<辞書>が<値>を含む。(辞書の要素にオブジェクトが含まれる場合、真を返す)
```

_例：_

```
辞書【「あ」が１、「い」が２、「う」が3】が辞書【「う」が3、「あ」が１、「い」が２】に等しい。(真)
dictionaryは辞書。dictionaryが空。(真)
```

#### 辞書の要素定義

空の辞書を識別子に割り当てる場合、以下の様に記述可能です。

```
形式１：<識別子>は、辞書であって、【】
形式２：<識別子>は、辞書【】
形式３型：<識別子>は、辞書。
```

形式３の場合、句点「。」は必須です。

### 列挙(Enumeration)

複数の要素(列挙子とその値)の集合です。

```
形式１：列挙【(要素が)、<(複数の)要素>】
形式２：列挙であって、(要素が、)<(複数の)要素>
```

キーワード「要素が」(「要素は」も可)は、省略可能です。  
要素の形式は、以下のとおりです。

```
形式１：<列挙子>は<値>
形式２：<列挙子>
```

<列挙子>は、列挙定義内のユニークな識別子であり、助詞`は`によって、値(オブジェクト)を指定することができます。  
また、形式２のように値を指定しない場合、値は 0 から順に数値が割り当てられます。  
(注：形式１は、[定義文](#定義文define-statement)と同じ形式です。)

要素が複数の場合、「と、」または記号「、」(または「,」(コンマ))で区切ります。  
値として数値を指定し、その後は値を指定しない場合、以降の値は順に、指定値に１を足した数値になります。

_列挙の例：_

```
曜日は、列挙であって、【要素が、
	月は「月曜」、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」。
】。
曜日の火の値。(「火曜」)
列挙【月、火、水、木、金、土、日】の火の値。(1)
列挙【aと、bと、cは10と、d】。(列挙【aは０、bは1、cは10、dは11】と同じ。)
```

#### 列挙要素のアクセス

列挙の要素を参照する方法は、以下の様に３通りあります。

```
形式１：<列挙>の<列挙子>
形式２：<列挙>・<列挙子>
形式３：・<列挙子>
```

形式２と３では、記号`・`(中黒、中点)を使って要素をアクセスします。  
形式３では、<列挙>が辞書に登録されている場合、つまり、定義文で識別子に定義されている場合に使えます。  
いずれも列挙子を持つ要素のオブジェクトが返ります。

さらに、上記の様に得られた要素オブジェクトを、以下の様にアクセスすることができます。

```
形式：<要素>の列挙子(識別子名(文字列)を返す)
形式：<要素>の値(識別子に定義された値を返す)
形式：<要素>の型(要素を含む列挙型名(文字列)を返す)
```

_要素アクセスの例：_

```
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日の型。(「列挙」)
曜日の日の型。(「曜日」)
曜日・火の列挙子。(「火」)
・火の列挙子。(「火」)
・火の値。（「火曜」）
木曜日は、・木。木曜日が、曜日の木に等しい。(真)
列挙【月、火、水、木、金、土、日】の日の型。(「」(空文字を返す)
```

また、述語`代入`(assign)によって、列挙の要素に値を代入したオブジェクトを得ることができます。

```
形式１：<値>を<要素>に代入する。(<値>が代入された<要素オブジェクト>を返す)
形式２：<要素>に<値>を代入する。(<値>が代入された<要素オブジェクト>を返す)
```

注： 列挙オブジェクトの要素(値)を更新することはできません。列挙の要素(識別子と値)は不変です。

_`代入`の例：_

```
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日の木の値。(「木曜」)
木曜日は、・木に「Thursday」を代入したもの。
木曜日の値。(「Thursday」)
曜日の木の値。(「木曜」)
```

この様に、<列挙オブジェクト>である識別子「曜日」の木の値は、代入によって変更されません。

さらに、２つの<要素>が等しいか否かは、述語`等しい`を使います。

```
形式：<要素１>(が)<要素２>に等しい。(２つの要素が等しい場合に真を返す)
```

注：<要素１>の句の助詞は、種類・有無を問わないが、<要素１>が識別子である場合、助詞`は`は使えない。(「<識別子>は〜」の形式は、定義文とみなされるため。)

これまで、列挙子を使った要素の参照を説明しましたが、さらに、述語`生成`(create)を用いて、要素の値から要素を生成(コピー)し、アクセスすることが可能です。

```
形式１：<値>で<列挙>から生成。(生成された要素オブジェクトを返す)
形式２：「<識別子名>」を<値>で<列挙>から生成。(生成された要素オブジェクトを識別子に代入する)
形式３：<列挙>から<値>で「<識別子名>」を生成。(生成された要素オブジェクトを識別子に代入する)
```

形式２と形式３では、指定した識別子名の識別子に生成した要素オブジェクトを代入します。  
注：識別子名は、文字列で指定します。(「」(カギ括弧)が必要。）

_要素生成の例：_

```
曜日は、列挙であって、【
  要素が、
    月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」。
】。
予定日は、「水曜」で曜日から生成したもの。予定日の列挙子。(「水」)
「Monday」を月曜日の値で曜日から生成する。Mondayの列挙子。(「月」)
曜日から「火曜」で「火曜日」を生成する。火曜日の列挙子。(「火」)
```

### 範囲(Range)

「〜以上〜以下」のような数値の範囲を表します。

```
形式１：範囲【<範囲式>】
形式２：範囲であって、<範囲式>
```

<範囲式>は、数値返す式と助詞`から`,`まで`,`以上`,`以下`,`未満`で構成されます。また、組み合わせにより、下限、上限、上下限の３通りを表現できます。  
`から`と`以上`は下限を表し、`まで`と`以下`と`未満`は上限を表します。  
上下限を表す場合は、`から`と`まで`、または、`以上`と`以下`(または`未満`)の組み合わせが可能です。

_範囲の例：_

```
１は範囲【１以上】にある。（真）
範囲【1以上5未満】が5を含む。(偽)
「あいうえお」の範囲【1から3まで】。(「いうえ」）
甲は、範囲であって、10未満。(甲は範囲【10未満】)
```

#### 範囲の判定

数値が`範囲`に属するか否かを判定するには、述語`ある`(be)、`ない`(not)、および`含む`(contains)を使って以下の様に記述します。(いずれも真偽値を返します。)

```
形式１：<数値>が<範囲>にある(ない)
形式２：<数値>は<範囲>にある(ない)
形式３：<範囲>が<数値>を含む
```

注：<数値>が<識別子>である場合、助詞`は`は使えません。(「<識別子>は〜」の形式は、定義文とみなされるため。)

_例：_

```
1が範囲【１以上２以下】にある(真)
11が範囲【１から10まで】にある(偽)
範囲【1以上】が3を含む(真)
範囲【1まで】が3を含む(偽)
```

また、２つの範囲が等しいか否かを判定するには、述語`等しい`を使って以下の様に記述します。

```
形式１： <範囲１>が<範囲２>に等しい
形式２： <範囲１>は<範囲２>に等しい
```

注：<範囲１>が<識別子>である場合、助詞`は`は使えません。(「<識別子>は〜」の形式は、定義文とみなされるため。)

_例：_

```
範囲【1から3まで】が範囲【1以上3以下】に等しい(真)
範囲【1から3まで】は範囲【1以上3未満】に等しい(偽)
```

#### 範囲の数

範囲内の数値の数を数える述語として、`数`、`空`があります。

```
形式：<範囲>の数(範囲内の数値の数を返す)
形式：<範囲>が空(範囲内に数値が無い場合に真を返す)
```

注：範囲内の数値を数えることができるのは、範囲式が上下限である場合のみです。それ以外ではエラーメッセージ「「範囲」の上下限が数値でないため、数えることができない。」が返ります。

_例：_

```
範囲【1から3まで】の数(3)
範囲【１以下】の数(エラー：「範囲」の上下限が数値でないため、数えることができない。)
範囲【1から3まで】が空(偽)
範囲【1以上1未満】が空(真)
```

なお、`文字列`(string)、`配列`(array)の範囲を表す「の範囲」については、それぞれ、[文字列の位置/範囲](#文字列の位置範囲)、[配列要素のアクセス](#配列要素のアクセス)を参照してください。  
また、配列が範囲を含むか否かについては、[配列の操作/判定](#配列の操作判定)を参照してください。

## 基本構文

プログラムを作成する上で基本的な構文を以下に示します。  
型に依存する式などの構文は、それぞれの型で説明しています。([値と型](#値literalと型type)参照)。また、型に共通する述語、その他の述語については、[述語](#述語predicate)および[スタック操作](#スタック操作stack-operation)で説明します。

### 定義文(Define Statement)

定義文は、識別子に定義内容を割り当てます。  
定義された識別子と定義内容は、辞書に登録されます。

```
形式：<識別子>は、<定義内容>。
```

<定義内容>は、オブジェクトを返す式、識別子、リテラルなどです。すなわち、解釈・評価の結果、オブジェクトになる内容を定義する必要があります。  
また、ブロックや、定義文を、定義内容とすることはできません。同じ<識別子>に定義した場合は、再定義(上書き)になります。

_定義文の例：_

```
aは1。(数値１をaに割り当てる。)
bはa。(bにaを割り当てる。→ b=1)
cは、1と2を足したもの。(1と2を足した結果3を、cに割り当てる)
挨拶は、「こんにちは」。(文字列「こんにちは」を、識別子「挨拶」に割り当てる。)
加算は、関数であって、入力がaとbで、aとbを足し、返す。(引数aとbを足して返す関数を、識別子「加算」に割り当てる。)
```

_定義文にできない定義内容の例：_

```
aは、bは１。(エラー。定義文は定義内容にできない。)
aは、【1と2を足す】。(エラー。ブロックは定義内容にできない。)
```

### 場合文(If-else Statement, Switch-case Statement)

場合文は、条件により実行処理を変えます。場合文には、以下の２つの形式があります。

```
形式１：<条件式>場合、【<真の実行処理>】(、それ以外は、【＜偽の実行処理＞】)。
形式２：<値>が、<値１>の場合、【<実行処理１>】、<値２>の場合、【<実行処理２>】、…、それ以外は、【<それ以外の実行処理>】。
```

注： ブロックの終わり`】`が、行末になる場合は、ブロックを省略可能です。

形式１では、<条件式>が評価された結果が「真」であれば<真のフロー>が実行され、「偽」であれば＜偽の実行処理＞が実行されます。  
「それ以外は、〜」は省略可能であり、その場合、条件式が「偽」であれば、単に<真の実行処理>をスキップします。

_形式１の例：_

```
甲は１。乙は２。甲が１より小さい場合【甲を表示し】、それ以外は、乙を表示する。(2(乙)が表示される。)
aは10。aが範囲【1以上10未満】にある場合、aを表示する。(範囲外のため10(a)は表示されない。)

甲は０。乙は１。
甲が１より小さい場合、甲を表示し、
それ以外は、乙を表示する。
※ 甲が１より小さいので、0が表示される。
```

注：「それ以外」の前(同行)にある<真の実行処理>のブロック`【】`は省略不可です。(省略すると、行末までが、<真の実行処理>になる。)

形式２では、<値>が以降の値１>、値２>、…のいずれかに一致した場合に、それぞれに対応した実行処理が実行されます。  
いずれにも一致しない場合は、<それ以外の実行処理>が実行されます。形式２では「それ以外は、〜」は、省略不可です。

_形式２の例:_

```
甲が、1 の場合【「い」を表示し】、2 の場合【「ろ」を表示し】、それ以外は、「ん」を表示する。
```

注：「それ以外」の前(同行)にある<実行処理>のブロックは省略不可です。

_形式２（ブロック省略)の例：_

```
フィボナッチ数は、関数であって、【入力が数字「数値」であり、本体が、
    数字が、
    １の場合、１を返す。
    ２の場合、２を返す。
    それ以外は、【
        数字から１を引き、フィボナッチ数を実行したものと、
        数字から２を引き、フィボナッチ数を実行したものを、
        足し、返す。
    】
】。
1から12まで反復【入力が数字で、数字でフィボナッチ数を実行し、表示する】。
※ 1から１２までのフィボナッチ数が表示される。
```

注：「１の場合」「２の場合」は、行末が、それぞれのブロックの終わりであるため、ブロック記号`【】`を省略しています。

形式２では、さらに、値として、配列または範囲を指定することができます。この場合、最初の<値>が、配列または範囲に属する(含まれる)場合に、それぞれの実行処理が実行されます。

_形式２(配列、範囲との比較)の例:_

```
aが、配列【1,3,5,7,9】の場合、【「奇数」を表示し】、配列【2,4,6,8,10】の場合、【「偶数」を表示し】、それ以外は、「対象外」を表示する。
aが、範囲【1以下】の場合、【aと1を足し】、範囲【2以上4未満】の場合、【aと2を足し】、それ以外は、aと3を足す。
```

さらに、`列挙`との組み合わせで以下の様に箇条書き風に表記できます。

_形式２(列挙との組み合わせ)の例：_

```
曜日は、列挙【月曜、火曜、水曜、木曜、金曜、土曜、日曜】。
今日は、・金曜。
今日が、
・土曜の場合、「土」を表示する。
・日曜の場合、「日」を表示する。
それ以外は、「平日」を表示する。
(「平日」が表示される。)
```

### 反復文(Loop(while, for) Statement)

反復文は、指定した条件等により実行処理を反復します。以下の５つの形式があります。

```
形式１：反復【(条件が、<条件式>の間、)<実行処理>】。
形式２：<数値>から<数値>まで（<数値>ずつ）反復【入力が<識別子(カウント値)>であり、<実行処理>】。
形式３：<範囲>を反復【入力が<識別子(カウント値)>であり、<実行処理>】。
形式４：<配列>を反復【入力が<識別子(値)>であり、<実行処理>】。
形式５：<辞書>を反復【入力が<識別子(キー)>と<識別子(値)>であり、<実行処理>】。
```

注：反復文の入力を示す「入力が」(または「入力は」)部分の終端(文字)には、句点「。」または「で」が必要です。「で、」「であり、」も可能ですが、読点「、」単独では終端になりません。

**形式１**では、<条件式>が真である場合、<実行処理>を反復します。(他のプログラム言語の while 文に相当)  
反復条件「条件が、<条件式>の間」のチェックは、<実行処理>の前に行われます。  
また、反復条件は省略することが可能ですが、その場合、述語`中止`で中止しない限り処理を反復します。

_形式１の例：_

```
※ 反復条件を指定
合計は０。数字は１。
反復であって、条件は、数字が１０より小さい間、合計に数字を足して代入。数字に１を足して代入。
合計を表示する。(45)

※ 反復条件を省略
合計は０。数字は１。
反復【
  合計に数字を足して代入。
  数字に１を足して代入。
  数字が９より大きい場合、中止する。
】。
合計を表示する。(45)
```

**形式２**では、指定した数値範囲で、指定した数値(ステップ数)ごと処理を反復します。(一般的なプログラム言語の for 文に相当)  
処理の中では、カウント値を利用できます。  
また、数値(ステップ数)は省略可能であり、その場合は、１ずつカウントアップします。さらに、負数を指定した場合は、カウントダウンします。

_形式２(カウントダウン)の例：_

```
数列は「」。
９から１まで−１ずつ反復【入力は数字。数列と、数字の文字列と「 」を足して代入】。
数列を表示する。(9 8 7 6 5 4 3 2 1 )
```

**形式３**では、指定した`範囲`の数値ごとに処理を反復します。処理をしている範囲の数値を、指定した識別子(入力識別子)で利用可能です。入力識別子の指定は省略できません。

_形式３(範囲の反復)の例：_

```
合計は０。
範囲【１以上１０未満】を反復【入力は数字、合計に数字を足して代入】。
合計を表示する。(45)
```

**形式４**では、指定した`配列`の要素で処理を反復します。処理をしている配列の要素を、指定した識別子(入力識別子)で利用可能です。入力識別子の指定は省略できません。

_形式４（配列の反復）の例：_

```
合計は０。
配列【１、２、３、４、５、６、７、８、９】を反復【入力は数字、合計に数字を足して代入】。
合計を表示する。(45)
```

**形式５**では、指定した`辞書`の要素(キーと値)で処理を反復します。処理をしている辞書(キーと値)の要素を、指定した識別子(入力識別子)で利用可能です。入力識別子は、２つ指定することが必要です。

_形式５（辞書の反復）の例：_

```
合計は０。
辞書【１が１、２が２、３が３、４が４、５が５、６が６、７が７、８が８、９が９】を反復【入力が索引と値。合計に値を足して代入】。
合計を表示する。(45)
```

注：形式３〜５は、述語`繰り返す`を使うことにより、同じことができます。

### 接続詞「かつ(And)」と「または(Or)」の構文

接続詞`かつ`(and)と`または`(or)は、述語と異なる形式の構文を持ちます。

接続詞`かつ`、`または`は、式を続けて記述することができます。  
判定は順次(注)ですが、ブロックで囲うことによって、判定の順序を変更できます。
(注：`かつ`と`または`の優先順位はありません。)

#### 論理積`かつ`(Logical And)

２つの論理式の論理積を返します。

```
形式：<論理式１>、かつ、<論理式２>(真偽値を返す)
```

_論理積の例：_

```
1が2に等しい、かつ、1が1に等しい。(偽)
1が1に等しい、かつ、2が2に等しい、かつ、3が3に等しい。(真)
```

#### 論理和`または`(Logical Or)

２つの論理式の論理和を返します。

```
形式：<論理式１>、または、<論理式２>(真偽値を返す)
```

_論理和の例：_

```
1が2に等しい、または、1が1に等しい。(真)
1が1に等しい、または、2が2に等しい、または、3が3に等しい。(真)
```

_和積混在の論理式の例：_

```
1が1に等しい、または、2が2に等しい、かつ、3が4に等しい。(偽)
1が1に等しい、または、【2が2に等しい、かつ、3が4に等しい。】。(真)
1が2に等しい、かつ、【2が2に等しい、または、3が3に等しい】。(偽)
```

ブロック`【】`がある論理式の判定が優先されます。

#### 選択肢`または`

`または`には、論理和だけでなく、値を選択的に判定するための形式があります。

```
形式：<値１>または<値２>…
```

これは、述語`ある`・`ない`・`等しい`と組み合わせ、以下の様に使われます。

```
形式１：<値>が<値１>または<値２>…である。(真偽値を返す)
形式２：<値>が<値１>または<値２>…に等しい。(真偽値を返す)
形式３：<値>が<値１>または<値２>…でない。(真偽値を返す)
形式４：<値>が<値１>または<値２>…に等しくない。(真偽値を返す)
```

形式１と形式２は同じ意味で、<値>が、<値１>または<値２>…に等しいかを判定します。  
形式３と形式４も同じ意味で、<値>が、<値１>または<値２>…に等しくないかを判定します。  
すなわち、形式３と形式４は、それぞれ、形式１と形式２の否定を意味します。

また、これらは、形式５の様に場合文で用いることで、より簡潔な表現で条件分岐を記載できます。

```
形式５：<値>が、値１>または値２>…の場合、
```

さらに、これらは、`配列`を使った以下の形式と同じ意味になります。

```
形式６：<値>が配列【<値１>、<値２>、..】にある。
形式７：<値>が配列【<値１>、<値２>、..】にない。
```

形式６は形式１、２と、形式７は形式３、４と同じ意味です。

_選択肢`または`の例：_

```
1が、1または2に等しい、かつ、2が2に等しい、または、3が3に等しい。(真)
3が範囲【１から2まで】または範囲【４から10まで】にある。(偽)
3が配列【１、２、３】にない。(偽。３が１または２または３でない、と同じ)
```

_場合文での使用例：_

```
曜日が、
・木曜または・日曜の場合、「休診日」と表示。
・土曜の場合、「午後休診」と表示。
それ以外は、「診療日」と表示。
```

### 条件演算式「によって」

条件が成立した場合と不成立の場合で、それぞれの値を返します。  
`場合文`を使うより、簡潔な記述が可能です。  
他のプログラム言語では、三項条件演算子(Ternary Condtional Operator)と呼ばれ、`a ? b：c`のように記述します。

```
形式１：<条件>によって、<値１>か<値２>
形式２：<条件>かによって、<値１>か<値２>
```

`場合文`と異なり、処理(ブロック)ではなく式であり、`【】`は不要です。また、<値２>の省略は不可です。  
<条件>の後の`か`の有無は任意です。(`か`は他に作用をしません。)

例：

```
条件は、1が2より小さい。甲は、条件によって10か20。甲。(10)
年齢は17歳。入場者は、年齢が18以上であるかによって、「成人」か「未成年」。入場者。(「未成年」)
```

## 関数(Function)と算出(Computation)

`関数`と`算出`は、共に一連の処理を定義・表現するためのものです。  
定義文により、これらに対応する識別子を、新たな述語として定義することができます。  
また、`関数`と`算出`は、必要に応じて、引数から得た入力で処理を行い、結果を返り値として返します。

### 関数(Function)

`関数`は、主に入力を得て処理を行い、結果をオブジェクトとして返します。(返されたオブジェクトは、スタックに格納されます。)

```
形式１：関数【(入力が、<入力定義>。)(本体が、)<実行処理>】
形式２：関数であって、(入力が、<入力定義>。)(本体が、)<実行処理>
```

#### 関数の入力定義

<入力定義>は、基本的に識別子を助詞`と`を使い、入力する識別子を必要個並べます。(入力の識別子は、他のプログラム言語では、仮引数と呼ばれます。)  
入力が無い場合は、入力定義は不要です。

```
形式：入力が、<識別子１>(と<識別子２>と…)。
```

注：「入力が」(または「入力は」)部分の終端(文字)には、句点「。」または「で」が必要です。「で、」「であり、」も可能ですが、読点「、」単独では終端になりません。

複数の引数を入力する場合、渡された引数の順に識別子に代入(入力)されます。たとえば、関数「加算」の入力が識別子`a`と`b`であった場合、`１と２を加算する。`の引数`1と`、`2を`は、`a`に 1、`b`に２がそれぞれ代入されます。(注：入力の際、助詞`と`と`を`は省かれます。)

引数の数が、入力として指定した識別子の数に満たない場合、エラーとなります。

#### 既定値を持つ入力（Default Parameter Values)

`関数`の入力識別子は、以下の形式で既定値を持つことができます。

```
形式：入力が、<識別子１>は<既定値１>(と、<識別子２>は<既定値２>と、…)。
```

既定値を指定した識別子は、関数に渡す引数を省略することが可能です。

ただし、識別子を[可変長(…)に指定](#入力チェック)した場合、既定値を持つことはできません。
(可変長の引数、すなわち、指定の型と格を持つ引数を省略することは可能です。その場合、識別子には空の配列が割り当てられます。)

また、既定値を指定した識別子と、指定していない識別子が混在する場合、既定値を持たない識別子を先に定義してください。(引数は、先頭から割り当てるため、後ろの識別子に正しく値を割り当てることができなくなります。)

注：入力識別子に既定値を指定し、かつ、識別子の<型>を指定した場合、既定値の型と指定<型>が一致しないと、エラーになります。(エラー：既定値の型が指定形式と一致しない。)

_既定値を持つ入力の例：_

```
甲は、関数【入力が、xと、yは1と、zは2。xとyとzを足す】。
(1) 1と2と3で甲を実行。(6)
(2) 1と2で甲を実行。(5)
(3) 1で甲を実行。(4)
```

`x`は既定値が定義されておらず、`y`と`z`は既定値を定義しています。  
(1)では、３つの引数を渡しているので、既定値は無視され、３つの入力識別子に引数が割り当てられます。  
(2)では、２つの引数を渡しているので、残りの`z`は既定値`2`が割り当てられます。  
(3)では、`x`に`1`が割り当てられ、残りは既定値が割り当てられます。

_可変長引数と既定値を持つ入力の例：_

```
挨拶は、関数【入力が、相手１「と…」と、相手２「に」と、呼びかけは「こんにちは」。
    相手１を「」と関数【入力が初期値と値。初期値と値と「、」を足す】でまとめたものと、
    相手２と「、」と、呼びかけと、「。」を足す。
】
(1)「Alice」と「Bob」と「Charlie」に「こんばんは」で挨拶する。(Alice、Bob、Charlie、こんばんは。)
(2)「Alice」と「Bob」に挨拶する。(Alice、Bob、こんにちは。)
(3)「Alice」に「おはよう」で挨拶する。(Alice、おはよう。)
```

`相手１`は格が「と」である可変長識別子、`相手２`は格が「に」である識別子、`呼びかけ`は既定値「こんにちは」を持つ識別子です。これらに引数を渡すことで、(1)〜(3)の様な文字列が返ります。

(1)は、可変長識別子`相手１`に「Alice と」と「Bob と」を、`相手２`に「Charlie に」を、`呼びかけ`には「こんばんは」を渡しています。`呼びかけ`の値は、既定値でなく「こんばんは」になります。  
(2)は、可変長識別子`相手１`に「Alice と」を、`相手２`に「Bob に」を渡し、`呼びかけ`には引数を渡していないため、その値は、既定値「こんにちは」になります。  
(3)は、可変長識別子`相手１`に引数を渡さず、`相手２`に「Alice に」を、`呼びかけ`には「おはよう」を渡しています。`呼びかけ`の値は、既定値でなく「おはよう」になります。

#### 関数の実行（Function Call)

`関数`の<実行処理>を実行するためには、述語`実行`または`する`を用い、関数を実行する(呼び出す)ことが必要です。以下の形式で関数を実行します。

```
形式１：<関数>(を)実行
形式２：<関数>(を)する
形式３：<関数>(を)実行する
```

関数は、実行されるまでは、引数や返り値として使用することができます。
([関数を引数とする例](#関数の使用例)を参照)

#### 述語`返す`(Return)

<実行処理>で結果を返すときは、述語`返す`(return)を使います。

```
形式：<値>(を)返す。
```

<値>を返し、<実行処理>を終了します。(`返す`に続く文、式等は無効です。)  
返す<値>は必須です。

`返す`を使わずに、暗黙的に返り値をオブジェクトとしてスタックに格納し、その後、別の処理を行うことも可能です。

また、値を返さずに処理を終了するには、述語`中止`を使います。

#### 関数の使用例

_関数の定義と実行例：_

```
(1) 二倍は、関数【入力がxで、xに2を掛け、返す】。５を二倍し、二倍する。(20)
(2) 加算は、関数【入力がaとbで、aにbを足す】。1に2を加算する。(3)
(3) 5で関数【入力がxで、x】を実行する。(5)
```

(２)と(３)の例では、`返す`を使わずに暗黙的にオブジェクトをスタックに格納し、実行処理を終了しています。

_関数を引数とする例：_

```
適用は、関数【入力がaとbと演算で、aとbを演算する】。
加算は、関数【入力がaとbで、aにbを足す】。10と2に、加算を適用する。(12)
減算は、関数【入力がaとbで、aからbを引く】。10と2に、減算を適用する。(8)
```

関数「適用」は、入力に２つの数値と関数を取り、引数の関数(「加算」「減算」)によって振る舞いを変更しています。

#### 入力チェック

引数の識別子の型と格をチェックすることが可能です。チェックするには、入力の識別子にかぎ括弧`「`と`」`を付けて、以下の様に記述します。

```
形式：<識別子>「<型>)(<格>(…))」
```

かぎ括弧内と識別子の数を合わせて「**シグネチャ**」と呼びます。

- <型>  
  引数の型をチェックします。(一致しない場合はエラー)
- <格>  
  引数の格(助詞)をチェックします。(一致しない場合はエラー)
- …(三点リーダー)  
  引数の数をチェックせず、述語`足す`の様に、同じ格が続く限り引数を処理します。  
  すなわち、指定した連続する<型><格>を持つ引数を配列にし、識別子に渡します。

これらに加え、引数の数もチェックします。引数の数が、指定した識別子の数に満たない場合はエラーになります。  
注：関数が多重定義されている場合、定義の中に一致するシグネチャがあればエラーにはなりません。([関数の多重定義](#関数の多重定義function-overload)を参照)

_入力チェックの例:_

```
(1) 加算は、関数【入力がa「数値」とb「数値」で、aにbを足す】。1と2の加算する。(3。型のチェックOK)
(2) 加算は、関数【入力がa「と」とb「を」で、aにbを足す】。1と2を加算する。(3。格のチェックOK)
(3) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。1に2を加算する。(3。型と格のチェックOK)
(4) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。「a」に「b」を加算する。(エラー：入力の型が異なる。入力の型：文字列)
(5) 加算は、関数【入力がa「数値に」とb「数値を」で、aにbを足す】。1と2を加算する。(エラー：入力の格が異なる。入力の格：と)
(6) 加算は、関数【入力がa「数値と…」とb「数値を」。aをbと関数【入力が初期値と値で、初期値に値を足す】でまとめ、返す】。1と2と3と4と5を加算する。(15)
```

(４)と(５)の例では、引数のシグネチャが異なるためエラーが返っています。  
(６)の例では、述語`まとめる`(reduce)を使い、1 から 5 までの合計を求めています。引数のシグネチャがチェック形式と一致しているので結果が返っています。  
この場合、`a`は、`…`の指定により可変長識別子となり、連続する格`と`を持つ引数`1と2と3と4と`が渡され、結果として`配列【1,2,3,4】`が代入されます。`b`には、格`を`を持つ引数`5を`が渡され、`5`が代入されます。

#### 関数の多重定義(Function Overloading)

関数を定義文で定義し、さらに以下の形式で定義することにより、関数を多重定義することができます。  
多重定義には、副詞`さらに`を使用します。

```
形式： <識別子>は、<関数定義１>。
      <識別子>は、さらに、<関数定義２>…
```

これにより、文脈(シグネチャの違い)に沿う様に述語(識別子)の振る舞いを変えることができます。  
シグネチャをチェックするためには、[入力チェック](#入力チェック)の形式で入力を指定します。これにより、シグネチャが一致する関数の処理が実行されます。  
多重定義した関数の実行は、定義とは逆順にシグネチャをチェックします。これにより、同じ入力形式を持った関数を定義した場合、あとから定義した関数が先に実行されます。  
また、`さらに`を付けずに定義した場合は、上書きされ最新の定義が有効になります。

_多重定義の例：_

```
合成は、関数【入力がa「文字列と…」とb「文字列を」で、aの最初にbを足し、返す】。
合成は、さらに、関数【入力がa「数値に」とb「数値を」で、aにbを足し、返す】。
合成は、さらに、関数【入力がa「文字列を」とb「文字列に」で、bにaを足し、返す】。
※
「あ」と「い」を合成する。(「あい」)
1に2を合成する。(3)
「あ」を「い」に合成する。(「いあ」)
```

関数「合成」を多重定義することによって、引数の種類によって振る舞いの違う述語を実現しています。

#### 多重定義における入力チェック処理

多重定義では、引数のシグネチャをチェックし、以下の様に一致した定義を呼び出します。

1. 関数定義時に、入力の数をキーとし、関数定義の配列を値とする、辞書を作成。
1. 多重定義時に、辞書の配列に関数定義を追加する。
1. 関数実行時に、スタックの引数の数を数え、辞書から一致する関数定義配列を取り出す。
1. 取り出した配列を逆順に(定義が最新のものから)、シグネチャが一致するかチェックする。
1. 一致した場合、引数を対応する識別子に代入し、定義を実行する。
1. シグネチャが一致しない場合、3.の数から１を減じた関数定義配列を取り出し、4.のチェックを行い一致すれば、定義を実行する。
1. 引数の数１つまでチェックしても一致しない場合、可変長の引数としてチェックを行い、一致すれば定義を実行する。
1. 一致しない場合、引数の無い関数定義があれば、実行する。
1. 無い場合、最後の関数定義で引数の入力チェックを行い、エラーメッセージを返す。

以上の様に、スタックで引数をチェックするため、スタックに期待する引数以外のオブジェクトがある場合は、多重定義チェックが誤動作する恐れがあります。誤動作する場合は、スタックと動作を期待する関数定義の入力形式が一致する様に調整が必要です。

#### クロージャ(Closure)

関数はクロージャに対応しており、関数外で定義された識別子をキャプチャすることができます。(算出は引数にできないため、クロージャに未対応)

_クロージャの例：_

```
外側は、関数【
  カウント値は、０。
  内側は、関数【
    カウント値と1を足し、「カウント値」に上書きする。
    カウント値を返す。
  】。
  内側を返す。
】
外側を実行し、「カウントアップ」に代入する。
カウントアップする。(1)
カウントアップする。(2)
```

関数「内側」で「カウント値」をキャプチャし、保持されたカウント値が「カウントアップ」(関数「外側」が返した関数「内側」)で更新されています。

### 算出(Computation)

`算出`には、主に２つの働きがあります。  
１つ目は、`関数`と同様に、主に入力を得て処理を行い、結果をオブジェクトとして返すことです。  
２つ目は、`型`の値要素として定義し、定義した値の識別子をアクセス(取得と設定)したときの実行処理を表現することです。(他のではアクセサ、あるいはコンピューテッドプロパティと呼ばれ、取得は getter、設定は setter と呼ばれています。)

１つ目については、関数の定義と同じ形式になります。

```
形式１：算出【(入力が、<入力定義>。)(本体が、)<実行処理>】
形式２：算出であって、(入力が、<入力定義>。)(本体が、)<実行処理>
```

また、２つ目については、以下の様な形式になります。

```
形式３：
  算出【
    設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
    取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>】
  】。
形式４：算出であって、設定が、【(入力が、<入力定義>。)(本体が、)<実行処理>】。取得が、【(入力が、<入力定義>。)(本体が、)<実行処理>。】。
```

形式３と４では、「設定」と「取得」の定義を１つの`算出`で行います。(設定、取得の順番は替えられません。「取得」の定義を省略し、「設定」だけにすることは可能です。)

`算出`は、`関数`と違い、**[関数の実行(呼び出し)](#関数の実行function-call)を必要としません。** すなわち、`算出`には、関数呼び出しのための`実行`あるいは`する`が不要で、実行はその評価時に行われます。
(このため、`算出`を`関数`の様に引数として使用することはできません。)  
ただし「設定」は、`算出`を定義した識別子に対し、値を述語`設定`(set)で設定したときに実行されます。

`算出`は、オブジェクトの属性(名詞)を表現したり、(語尾の変化する)動詞や形容詞を表現したりすることに用いることにより、日本語らしい表現を可能とします。
一方、`関数`は、`する`を接続して動詞化するサ変名詞として、もしくは、その他「〜を実行する」を使う名詞としての使い方が適しています。

形式１、２は、形式３、４の「設定」定義が無い形式で、動作に差はありません。  
すなわち、形式３、４の「取得」は、形式１、２と同等です。

_`算出`(形式２)の例：_

```
加えるは、算出【入力がa「文字列に」とb「文字列を」。aとbを足す】。「い」に「ろ」を加える。(「いろ」)
税込は、算出であって、入力が金額。金額を10で割って、金額を足す。100円の税込。(110)
```

算出「加える」は、２つの文字列を足す処理を動詞で表現しています。(連用形による語尾変化にも対応します。)  
算出「税込」は、計算方法を表現する名詞になっており、金額の属性を表しています。

`設定`を伴う形式３、４については、[算出による要素のアクセス](#算出による要素のアクセスcomputed-property)で説明します。

#### `算出`の多重定義

`算出`を１つの定義文で、`設定`と`取得`に副詞`さらに`を付け加えることにより、個別に多重定義することができます。

```
形式５： <識別子>は、算出【
    設定が、【<関数定義１>】。
    設定が、さらに、【<関数定義２>】。
    …
    取得が、【<関数定義３>】
    取得が、さらに、【<関数定義４>】
    …
  】。
```

ここで、<関数定義ｎ>とは、入力定義と実行処理を持つ、通常の関数定義で、<関数定義２>は<関数定義１>の、<関数定義４>は<関数定義３>の多重定義になります。  
(注：ここで、それぞれは、入力形式(シグネチャ)が異なる必要があります。)

また、以下の様に、これとは別に定義文を追加することにより、`算出`を多重定義することができます。

```
形式６： <識別子>は、さらに、算出【<関数定義>】。
```

`算出`の定義が形式１、２である場合、[関数の多重定義](#関数の多重定義function-overloading)と同じく`算出`の「取得」を多重定義したことになります。

_`算出`の多重定義の例：_

```
加えるは、算出【入力がa「数値」とb「数値」で、aにbを足し、返す】。
加えるは、さらに、算出【入力がa「文字列」とb「文字列」で、aにbを足し、返す】。

「あ」に「い」を加える。(「あい」)
1に2を加える。(3)
```

一方、形式３、４の場合は、「取得」と「設定」を別個に多重定義することになります。

```
形式７：
  <識別子>は、さらに、算出【
    設定が、さらに、【<関数定義>】
    取得が、さらに、【<関数定義>】
  】。
形式８：<識別子>は、さらに、算出であって、設定が、さらに、【<関数定義>)】。取得が、さらに、【<関数定義>】。
```

この場合、「取得」と「設定」の後につける`さらに`は必須です。  
この`さらに`を記述しない場合は、「取得」または「設定」を再定義することとなり、それ以前の多重定義は無効になります。

_`算出`の多重定義の例：_

```
(1) 加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。
(2) 加えるは、さらに、算出【取得が、さらに、【入力がa「数値に」とb「数値を」で、aにbを足し、返す】】。
(3) 加えるは、さらに、算出【
      取得が、【入力がa「文字列」とb「文字列」で、aにbを足し、返す】
      取得が、さらに、【入力がa「文字列に」とb「文字列を」で、aにbを足し、返す】
    】。
(4) 「い」に「ろ」を加える。(「いろ」)
(5) １に２を加える。(エラー：入力の型が異なる。入力の型：数値)
```

この例では、「数値」どうしを足す`算出`は、「文字列」どうしを足す`算出`の多重定義で再定義(＊)されています。したがって、「1 と 2 を加える」は、エラーになります。(＊「加える」の(３)の定義の最初の「取得」に`さらに`が無いため再定義となる。)

## 型(Type)と規約(Protocol)

述語`型`(type)は、オブジェクトの型を定義・表現します。これにより、`数値`や`文字列`の様な組み込み型ではない、独自の型を作ることができます。  
また、述語`規約`(protocol)は、`型`が準拠するルールを定義・表現します。`規約`により、複数の型で共通となる性質を抽象化することができます。  
規約による共通化された呼び出し(インタフェース)により、呼び出す側は、異なる型を同じ様に扱うことが可能となります。さらに、呼び出された型ごとに、型に応じた振る舞いを定義をすることが可能となります。  
組み込み型も内部で規約を利用しており、例えば、述語`数`は、`配列`、`辞書`、`列挙`等の異なる型のオブジェクトに対し、型に応じた要素数を返すことができます。(参照：[オブジェクトに対する述語](#値literalとオブジェクトobject))

### 型(Type)

`型`は、値や関数などの定義(要素)の集合です。

```
形式１：型【(本体が、)<識別子>は<定義>…】
形式２：型であって、(本体が、)<識別子>は<定義>…。
```

注：「本体が、」は「本体は、」でも良い。また省略可。

定義した要素は、後述する型から生成されたオブジェクト(インスタンス)が持つ辞書に登録されます。

#### インスタンスの生成(New Operator)

`型`は、雛形であり、以下の述語`生成`によって生成されたオブジェクトが実体(インスタンス)となります。  
`型`に定義された要素には、`型`でなくインスタンスにアクセスします。

```
形式１：(「<識別子>」を)(<引数>で)<型>から生成
形式２：<型>から(<引数>で)「<識別子>」を生成
```

注：<識別子>にはかぎ括弧`「」`が必要

いずれも、<識別子>に、<型>から生成されたインスタンスが代入されます。(引数については後述)  
また、以下の様に定義文でインスタンスを定義することも可能です。

```
形式３：<識別子>は、(<引数>で)<型>から生成
形式４：<識別子>は、<型>から(<引数>で)生成
```

#### インスタンス要素のアクセス

インスタンスに対する要素のアクセスは、他の型と同じく助詞`の`を使いますが、必要に応じて任意の助詞を使うことができます。

```
形式１：<インスタンス>の<要素(識別子名)>
形式２：<インスタンス><任意の助詞><要素(識別子名)>
```

_例：_

```
車の色。(「車」というインスタンスの要素「色」にアクセス)
40Lを車に給油する。(「車」の要素「給油」という関数に、助詞「に」を使用してアクセス)
```

また、要素に値を書き込む場合は、述語`設定`(set)を使います。([`設定`(Set)](#設定set)参照)

ただし、インスタンスの要素は、既定では外部からのアクセスを許可していません。  
許可をするためには、述語`利用可能`を使い要素を利用可能にする必要があります。

```
形式：「<要素(識別子名)>」(と「<要素(識別子名)>」…)は利用可能。
```

注：<要素(識別子名)>にはかぎ括弧`「」`が必要
注：`利用可能`は、本体の中(ブロック)で定義してください。

#### インスタンス生成時の初期化(Initialization)

また、型からインスタンスを生成する際に行う「初期化処理」(initializer)を`型`に定義することができます。  
さらに、型からインスタンスを生成する際に、引数(入力)を指定することが可能です。同じ型で、異なる引数で生成することにより、異なる値や振る舞いを持つインスタンスを生成することができます。  
引数は、[関数の入力](#関数の入力定義)と同様に、初期化処理に渡すことができます。同様に[入力チェック](#入力チェック)を行うこともできます。

```
形式：初期化が、【<関数定義>】
```

注：助詞`が`は`は`でも良い。

<関数定義>は、[関数](#関数function)や[算出](#算出computation)の定義と同じです。  
さらには、[算出と同様の多重定義](#算出の多重定義)も可能です。

```
形式：
初期化が、【<関数定義１>】。
初期化は、さらに、【<関数定義２>】。
…
```

例：

```
甲は、型であって、【
    初期化は、【aは１。bは2。】
    初期化は、さらに、【入力がaで、bは3。】
    初期化は、さらに、【入力がaとb。】
    「a」と「b」は利用可能。
】
乙は甲から生成する。乙のaと乙のbを足す。(3。`生成`で入力の無い１番目の初期化が呼ばれる)
「乙」を、2で甲から生成する。乙のaと乙のbを足す。(5。`生成`で入力が１つの２番目の初期化が呼ばれる)
甲から、3と4で「乙」を生成する。乙のaと乙のbを足す(7。`生成`で入力が２つの３番目の初期化が呼ばれる)
```

多重定義された`初期化`は`生成`に与えられた引数で実行され、インスタンスが生成されます。  
初期化内で定義された識別子や入力識別子は、インスタンス内の辞書に記録されるため、これらを`利用可能`にすることによって、外部から助詞`の`によってアクセスすることが可能になります。

また、`初期化`の多重定義において、インスタンス自身を表す`自身`を使って、１つの定義から他の初期化処理を呼び出すことができます。

```
形式：自身の初期化
```

（注：`初期化`内で、自身の初期化を呼び出す際、異なる初期化を呼び出さないと、処理のループが発生します。)

_`初期化`の呼び出し例：_

```
甲は、型であって、【
    初期化は、【入力がaとbとc。】
    初期化は、さらに、【入力がa、aと1と2で、自身の初期化をする。】
    初期化は、さらに、【入力がaとb、aとbと1で、自身の初期化をする。】
    合計は、算出【aとbとcを足す。】
    「合計」は、利用可能。
】
```

多重定義によって、入力の形式(この例では引数の数)によって、異なる初期化処理が呼び出されますが、２番目と３番目の`初期化`は、それぞれ１番目の`初期化`を呼び出し、a と b と c を初期化しています。

#### 算出による要素のアクセス(Computed Property)

`算出`を使うと、インスタンス内の他の要素に間接的にアクセスしたり、一定の処理をしたりすることが可能となります。  
また、通常の関数定義と同様に、入力の指定も可能です。(算出の詳細については、[算出(Computation)](#算出computation)を参照)

```
形式１：
  <識別子>は、算出【
    設定が、【<設定の関数定義>】
    取得が、【<取得の関数定義>】
  】。
形式２：
  <識別子>は、算出であって、設定が、【<設定の関数定義>】。取得が、【<取得の関数定義>】。
```

`取得`は、他の要素と同様なアクセス方法`<インスタンス>の<要素(識別子)>`で、実行することができます。
また、`設定`は、[述語`設定`(set)](#設定set)を使って、実行します。

_`算出`によるアクセス例：_

```
温度は、型であって、【
    摂氏は、0度。
    華氏は、算出【
        設定が、【入力が設定値で、設定値から３２を引いたものに５を掛け、９で割り、「摂氏」に上書きする。】
        取得が、【９に摂氏を掛け５で割ったものに、３２を足す。】
    】。
    「摂氏」と「華氏」は利用可能。
】。
気温は、温度から生成する。
気温の摂氏。(0)
気温の華氏。(32)
気温の要素「摂氏」に20度を設定する。気温の摂氏。(20)
気温の華氏。(68)
気温の要素「華氏」を32度に設定する。気温の摂氏。(0)
```

注：`算出`の`設定`において、要素「摂氏」は外部(呼び出し元)になるため、`代入`ではなく`上書き`を使います。([`上書き`](#上書きoverwrite)参照)

上記例では、算出により摂氏と華氏の変換を実現しています。`取得`、`設定`、それぞれで変換処理をし、変換した値を返しています。

#### 型の要素(Static Member)

`型`の定義では、インスタンスだけでなく、型自身も要素「`型の要素`」を持つことができます。  
(`型の要素`は、型が内部で持つ辞書に登録されたオブジェクトです。)  
また、`型の要素`はインスタンスとは異なり、全て利用(外部からのアクセス)可能です。

```
形式：型の要素が、【<識別子>は<定義>…】
```

要素へのアクセス方法は、インスタンスではなく型の識別子(型名)を指定する以外は、インスタンスと同じです。

_例：_

```
挨拶は、型であって、【
    型の要素が、【宛名は、「田中」。本文は、算出【「こんにちは、」と宛名と「さん。」を足す】】。
】。
挨拶の本文。(「こんにちは、田中さん。」)
挨拶の要素「宛名」を「佐藤」に設定した挨拶の本文。(「こんにちは、佐藤さん。」)
```

型「挨拶」の要素「宛名」を変更し、「本文」を読み出しています。

#### 型の定義順序

`型`を定義する場合、以下の順番(*)で、各定義(ブロック)を行います。(*必要な定義以外は省略可能。)

```
形式：型【
    準拠する規約は、<規約>。
    型の要素は、【<型の要素定義>】
    初期化は、【<初期化定義>】
    本体は、【<要素の定義>】
】
```

注：「準拠する規約」については、[後述](#準拠する規約)参照。

#### 型の拡張(Type Extension)

`型`を副詞`さらに`を使って定義を拡張(追加や変更)することが可能です。(注：`数値`や`文字列`などの組み込み型は、拡張することができません。)

```
形式１：<識別子>は、さらに、型【<拡張定義>】
形式２：<識別子>は、さらに、型であって、【<拡張定義>】
```

追加する要素が、定義済みである場合には、再定義(値または定義の上書き)になります。
`初期化`および`関数`、`算出`については、副詞`さらに`を使って多重定義にすることができます。

_拡張定義の例：_

```
甲は、型であって、【
    初期化は、【入力がaとbとc。】
    初期化は、さらに、【入力がaで、aと1と2で、自身の初期化をする。】
    合計は、算出【aとbとcを足す。】
    「合計」は、利用可能。
】
甲は、さらに、型であって、【
    初期化は、さらに、【入力がaとbで、aとbと1で、自身の初期化をする。】
】
※
乙は、1と2と3で、甲から生成する。乙の合計（6)
乙は、1と2で、甲から生成する。乙の合計（4)
乙は、1で、甲から生成する。乙の合計(4)
```

型「甲」の初期化を拡張(多重定義)しています。追加された初期化により、引数が２つ（１と２）で生成した乙の合計は(1+2+1 で)４になります。

### 規約(Protocol)

`規約`は、主に`型`が準拠すべき要素(値や関数)の形式を定めるもので、以下の様な形式をしています。

```
形式１：規約【(準拠する規約は、<規約>。)(条項は、)<要素の定義>。】
形式２：規約であって、【(準拠する規約は、<規約>。)(条項は、)<要素の定義>。】
```

準拠する規約、および条項は、複数の定義することができます。

#### 準拠する規約

`準拠する規約`は、当該規約が前提とする(準拠する)規約であり、複数の規約を指定することができます。  
`型`が規約に準拠する際には、この<準拠する規約>にも準拠する必要があります。

```
形式：(準拠する)規約は、<規約１>(と、<規約２>と、…)。
```

注：「準拠する」は省略可。「規約は」は「規約が」も可。「と、」は「、」でも可。

<規約 n>は、定義した規約の識別子名で、かぎ括弧`「」`は無くても構いません。

#### 条項(Clauses)

`規約`の条項は、以下の様な形式で定義します。

```
形式１：<識別子>は、「<型名>」
形式２：型の<識別子>は、「<型名>」
```

注：<型名>を囲うかぎ括弧`「」`は必要。

条項として、要素の<識別子>とその<型名>を規定します。  
形式２は、`型の要素`([参照「型の要素」](#型の要素static-member))の規定になります。

さらに、`関数`、`算出`(`設定`および`取得`)では、その入力形式を規定することができます。

```
形式３：(型の)<識別子>は、関数【入力が<入力形式>】
形式４：(型の)<識別子>は、算出【入力が<入力形式>】
形式５：(型の)<識別子>は、算出【
                          設定は、【入力が<入力形式>】
                          取得は、【入力が<入力形式>】
        】
```

(注：形式５で、「取得は、」の定義は、省略可。)

`関数`と`算出`で、入力形式の規定が不要である場合は、形式１、２の様にそれぞれの<型名>だけ記述します。

#### 規約の準拠方法

`型`を、規約に準拠させるためには、最初に[`準拠する規約`の定義](#準拠する規約)をします。  
さらに、規約の条項の定義に沿った型を持った<識別子>を全て定義します。  
必要に応じて、`関数`と`算出`では、指定した入力形式に従った`関数`、`算出`を定義します。

規約に準拠している定義が見つからない、または、入力形式が異なる場合は、エラーメッセージを出力します。

_準拠方法の例：_

```
『通貨表記』は、規約であって、【
    記号は、「文字列」
    コードは、「文字列」
】
ユーロは、型であって、準拠する規約は、『通貨表記』。記号は「€」。コードは「EUR」。
米ドルは、型であって、準拠する規約は、『通貨表記』。記号は「$」。コードは「USD」。
国名は、列挙【米国と、スペインと、英国と、ギリシア、日本】。
表記は、関数であって、【入力が通貨国「国名」。
    通貨国が、
    ・スペインまたは・ギリシアの場合、ユーロから生成し、返す。
    ・米国の場合、米ドルから生成し、返す。
    それ以外は、無を返す。
】
※
・ギリシアで表記したコードを表示する。(EUR)
・スペインで表記した記号を表示する。(€)
・米国で表記したコードを表示する。(USD)
・英国で表記したコードを表示する。(『コード』(識別子)が定義されていない。)
```

注：規約『通貨表記』の二重かぎ括弧は規約を目立たせる目的で、無くても構いません。また、「表記した」は「表記し、」でも同じです。

例では、ユーロと米ドルは、規約『通貨表記』に準拠しており、関数『表記』で、入力の国名に対応する国別インスタンスを生成します。これにより、各インスタンスの要素である国ごとに、共通した通貨の「記号」と「コード」を表示する様にできます。  
さらに、『通貨表記』に準拠したポンドや日本円を定義し、関数『表記』に加えれば、同様に「記号」と「コード」を扱うことができます。

#### 規約の実装定義(Protocol Extension)

`規約`に、副詞`さらに`を使って、既定の実装を定義することが可能です。

```
形式１：
    <識別子>は、規約であって、<規約の定義>。
    <識別子>は、さらに、型であって、<規約の実装定義>。
形式２：
    <識別子>は、規約【<規約の実装定義>】
    <識別子>は、さらに、型【<規約の実装定義>】
```

既定の実装を持つことにより、規約を準拠している型に共通するような既定の振る舞いをすることができます。

_規約の実装定義の例：_

```
Objectは、規約【countは、「算出」。】
Objectは、さらに、型【countは、算出【「エラー：数えることはできない。」】】
Numberは、型【
    準拠する規約は、Object。
    初期化は、【入力はn「数値」、numberはn。】
】
Booleanは、型【
    準拠する規約は、Object。
    初期化は、【入力はb「真偽値」、booleanはb。】
】
Stringは、型【
    準拠する規約は、Object。
    初期化は、【stringは「」】
    初期化は、さらに、【入力はs「文字列」、stringはs。】
    countは、算出【stringの数】
】
Arrayは、型【
    準拠する規約は、Object。
    初期化は、【arrayは配列【】】
    初期化は、さらに、【入力はa「配列」、arrayはa。】
    countは、算出【arrayの数】
】
※
1でNumberから生成し、count。(「エラー：数えることはできない。」)
真でBooleanから生成し、count。(「エラー：数えることはできない。」)
「あいうえお」でStringから生成し、count。(5)
配列【1,2,3】でArrayから生成し、count。(3)
```

例では、count を実装した String と Array は要素の数を算出し、実装していない Number と Boolean はエラーを出力します。  
このように、規約に準拠することによって必要な定義(count)をし、既定ではエラーを表示するという実装が可能となります。

## 述語(Predicate)

主に、型に共通、または特定の型に依存しない述語について、以下に説明します。

### オブジェクトおよびその要素を操作する述語

#### `設定`(Set)

オブジェクトの要素に値を設定します。  
対象となるオブジェクトは、インスタンスの要素、および型の要素です。  
要素が`算出`である場合は、述語`設定`により算出の設定処理を行います。([算出による要素のアクセス](#算出による要素のアクセスcomputed-property)参照)

```
形式１：<値>(を)<オブジェクト>の要素「<識別子>」に設定する。
形式２：<オブジェクト>の要素「<識別子>」に<値>を設定する。
形式３：<オブジェクト>の要素「<識別子>」を<値>に設定する。
```

注： 形式 2 と形式３では、格助詞`に`と`を`が逆になっています。

_設定の例：_

```
自動車は、型であって、【
    型の要素が、【ハンドルは「右」。】
    初期化が、【入力が残量で、燃料量は、残量。色は「黒」。】
    給油は、関数であって、【入力が給油量で、
        燃料量に給油量を足し、「燃料量」に上書きし、燃料量を返す。
    】
    「燃料量」と「給油」と「色」は利用可能。
】
自動車の要素「ハンドル」を「左」に設定する。
黒い車は、10Lで自動車から生成する。
30Lを黒い車に給油する。
黒い車の要素「色」に「白」を設定する。
※
自動車のハンドル(「左」)
黒い車の燃料量。(40)
黒い車の色。(「白」)
```

例では、型の要素「ハンドル」と、インスタンス「黒い車」の要素「色」に、それぞれ値を設定しています。

#### `代入`(Assign)

値をオブジェクトに代入します。  
対象となるオブジェクトは、識別子、配列の要素、列挙子です。

#### 識別子に代入

```
形式１：<値>を<識別子>に代入
形式２：<識別子>に<値>を代入
```

形式１と形式２は、既存の識別子に値を代入します。  
識別子を定義してない場合、<識別子>には以下の様に`「」`(かぎ括弧)、または`『』`(二重かぎ括弧)が必要です。

```
形式３：<値>を「<識別子>」に代入
形式４：「<識別子>」に<値>を代入
```

`代入`は、定義文で識別子を定義(または再定義)したのと同じであり、文脈や意図によって選択が可能です。

_識別子に代入の例：_

```
甲は1。甲に「い」を代入する。甲。(「い」)
「甲」に1を代入。甲。(1。`甲は１。`と同じ。)
1と2を足し、「乙」に代入する。乙。(3)
```

#### 識別子に計算をして代入

識別子に、算術演算等の計算・操作をし、結果を代入します。  
 他のプログラム言語では、`a += 1`などの形式で表現され、`+=`を「複合代入演算子(compound assignment operator)」と呼んでいます。

```
形式５：<識別子>(に)<計算し>て代入
```

計算に使える述語は、`足す`、`掛ける`、`割る`、`引く`、`負数`、`追加`、`削除`、`逆順`です。(注）  
識別子は、**定義済みである必要**があります。また、`代入`の前には、助詞`て`が必要です。  
(注：未定義の識別子は、[定義文](#定義文define-statement)で定義する際に、<定義内容>で計算・操作することができます。)

_識別子に計算をして代入する例：_

```
xは１。xに1を足して代入。x。(2)
xは１。xから1を引いて代入。x。(0)
xは１。xを3から引いて代入。x。(2)
xは２。xで6を割って代入。x。(3)
xは１。xを負数にして代入。x。(-1)
xは配列【１、２】。xに３を追加して代入。x。(配列【１、3】)
xは辞書【「い」が1、「ろ」が2】。xから「い」を削除して代入。x。（辞書【「ろ」が2】)
xは「あいうえお」。xを逆順にして代入。x。(「おえういあ」)
xは２。xに2を掛け、3を足し、4を引いて代入する。x。(3)
```

この様に、計算と代入の式を簡潔に記述することが可能です。

注：　  
計算して代入は、計算結果、すなわち代入する値(オブジェクト)をどの識別子に代入するかを知るため、オブジェクトの名前を識別子名にしています。  
(通常、オブジェクトの名前は、辞書に登録されるときに識別子名が割り当てられます。)  
よって、計算に使う述語が、計算結果に識別子名を引き継げる場合は、計算を連続して行うことが可能です。(上記例の最後参照）  
逆に識別子名を引き継げない場合は、代入ができません。

#### 配列に代入

配列の指定位置に値を代入します。([配列要素のアクセス](#配列要素のアクセス)を参照)

```
形式５：<配列>の位置<数値>に<値>を代入
形式６：<値>を<配列>の位置<数値>に代入
形式７：<配列>の位置「<識別子>」に<値>を代入
形式８：<値>を<配列>の位置「<識別子>」に代入
```

注１：いずれも<値>を指定位置に代入した<配列>を返します。  
注２：「<識別子>」は、『<識別子>』(二重かぎ括弧)も可

#### 列挙子に代入

列挙の要素に値を代入したオブジェクトを得ることができます。([列挙要素のアクセス](#列挙要素のアクセス)を参照)

```
形式９：<値>を<列挙子>に代入
形式１０：<列挙子>に<値>を代入
```

注：いずれも<値>を列挙子に代入した<要素オブジェクト>を返します。

#### `上書き`(Overwrite)

`関数`や`算出` 内で、呼び出し元の識別子に値を上書きします。  
通常、[識別子の有効範囲(scope)](#識別子の有効範囲scope)外(呼び元)の識別子は、ローカル(呼び先)から値を参照することが可能ですが、書き込み(代入)はできません。呼び元の識別子に書き込みたい場合、`上書き`を使用することにより、値を書き込むことが可能です。  
(注：ローカルと呼び出し元とに同じ名前の識別子がある場合、`代入`はローカル、`上書き`は呼び元の識別子にそれぞれ代入されます。)  
形式は、`代入`と同じですが、呼び元で識別子が定義されていない場合は、`上書き`不可(エラー)です。

```
形式１：<値>を<識別子>に上書き
形式２：<識別子>に<値>を上書き
形式３：<識別子>(に)<計算し>て上書き
形式４：<配列>の位置<数値>に<値>を上書き
形式５：<値>を<配列>の位置<数値>に上書き
形式６：<配列>の位置「<識別子>」に<値>を上書き
形式７：<値>を<配列>の位置「<識別子>」に上書き
形式８：<値>を<列挙子>に上書き
形式９：<列挙子>に<値>を上書き
```

_上書きの例１_

```
甲は、配列【１、２、３】。乙は２。関数【５を甲の位置『乙』に上書きする。】を実行する。甲の最後。(5)
インクリメントは、算出【xに1を足して上書きし、xを返す】。xは1。インクリメント。(2)
```

_上書きの例２_

```
キュー(FIFO)は、配列。
入れるは、算出であり、入力が値で、キューに値を追加して上書きする。
取り出すは、算出であり、値はキューの先頭。キューが空でない場合、キューの残りをキューに上書きする。値を返す。
3を入れる。
5を入れる。
取り出す。(3)
```

#### `追加`(Append)と`削除`(Remove)

#### `追加`(Append)

オブジェクトに、要素またはオブジェクトを追加します。  
対象となる<オブジェクト>は、`配列`と`辞書`です。

```
形式１：<オブジェクト>に<要素>を追加する。
形式２：<要素>(を)<オブジェクト>に追加する。
形式３：<オブジェクト１>に<オブジェクト２>を追加する。
```

注：オブジェクトが辞書の場合、要素は「<キー>が<値>」になります。  
注：形式３で追加できるオブジェクトは、同型のオブジェクトです。

`配列`への要素/配列の追加については、[配列要素のアクセス](#配列要素のアクセス)を参照。  
また、`辞書`への要素/辞書の追加については、[辞書要素のアクセス](#辞書要素のアクセス)を参照。

#### `削除`(Remove)

オブジェクトから、要素を削除します。

```
形式１：<配列>から<数値(位置)>を削除する。
形式２：<配列>から「先頭」/「後尾」/「全て」を削除する。
```

注：「先頭」は「最初」でも良い。「後尾」は「最後」でも良い。

`配列`の削除については、[配列要素のアクセス](#配列要素のアクセス)を参照。

```
形式３：<辞書>から<キー>を削除する。
形式４：<キー>を<辞書>から削除する。
形式５：<辞書>から「全て」を削除する。
```

`辞書`の削除については、[辞書要素のアクセス](#辞書要素のアクセス)を参照。

#### `含む`(Contains)

オブジェクトに、値が含まれているか否かを判定します。  
対象となるオブジェクトは、`文字列`、`範囲`、`配列`、`辞書`です。

```
形式：<オブジェクト>が<値>を含む。(真偽値を返す)
```

_`含む`の例：_

```
「かきくけこ」が「く」を含む。(真)
範囲【1以上5未満】が5を含む。(偽)
配列【１、２、３、４、５】が3を含む。(真)
配列【１、２、３、４、５】が配列【１、３】を含む。(真)
配列【１、２、３、４、５】が範囲【６以上】を含む。(偽)
```

また、オブジェクトが関数で定義した条件を満たす値/要素を含むか否かを判定します。  
関数では、入力(オブジェクトの要素)が満たす条件を記述します。

```
形式：<オブジェクト>が<関数(条件)>を含む。(真偽値を返す)
```

`関数`を使った`含む`の例：

```
配列【１、２0、３、４0、５】が、関数【入力が数値で、数値が10より大きい】を含む。(真)
辞書【「あ」が１、「い」が２、「う」が30】が、関数【入力がキーと値で、値が10より大きい】を含む。(真)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。

#### `繰り返す`(Foreach)

オブジェクトの要素ごとに、関数で定義した処理を実行します。  
関数では、オブジェクトの要素が入力になります。

```
形式：<オブジェクト>で<関数>を繰り返す。
```

`繰り返す`の例：

```
合計は０。範囲【1から９まで】で関数【入力は数字、合計に数字を足して上書き】を繰り返し、合計を表示。(45)
合計は０。配列【１、２、３、４、５、６、７、８、９】で関数【入力は数字、合計に数字を足して上書き】を繰り返し、合計を表示。(45)
合計は０。辞書【1が１、2が２、3が３、4が４、5が５、6が６、7が７、8が８、9が９】で関数【入力は索引と値、合計に値を足して上書き】を繰り返し、合計を表示。(45)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。

#### `写像`(Map)

オブジェクトの各要素に、関数で定義した処理を行った(変換した)結果で、オブジェクトを再構成します。  
すなわち、オブジェクトの各要素を関数で、写像(変換)します。

```
形式１：<オブジェクト>を<関数>で写像する。
```

関数では、オブジェクトの要素を入力とし、変換した結果を出力します。

`写像`の例：

```
二倍は、関数【入力が数値で、数値に２を掛ける】。
配列【１、２、３、４、５】を二倍で写像する。(配列【2、4、6、8、10】)
範囲【1から5まで】を二倍で写像する。(配列【2、4、6、8、10】)
辞書【「あ」が１、「い」が２、「う」が30】を、関数【入力がキーと値で、値に2を掛ける】で写像する。(配列【4、２、60】)
```

注：`辞書`の場合、関数の入力は２つ(キーと値)必要です。また、辞書の要素の順序は不定なので、結果の配列の順序も不定です。

例では、関数「二倍」が、オブジェクトの要素を入力とし、２を掛けた結果を出力し、配列を再構築しています。

また、`写像`は`範囲`を、範囲に含まれる数値の配列に変換します。

```
形式２：<範囲>を写像する。
```

_配列への変換の例：_

```
範囲【1以上5以下】を写像する。(配列【１、２、３、４、５】)
範囲【1以上6未満】を写像する。(配列【１、２、３、４、５】)
```

辞書を配列に写像するためには、関数で、キーまたは値のいずれを変換するのか指定する必要があるため、形式１で記述します。

_辞書の配列への変換例：_

```
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を関数【入力がキーと値。キー】で写像し、並べ替える。(配列【１、２、３、４、５】)
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を関数【入力がキーと値。値】で写像し、並べ替える。(配列【「１」、「２」、「３」、「４」、「５」】)
```

#### `絞り込む`(Filter)

関数で定義した条件で、オブジェクトの要素を絞り込みます。  
対象となるオブジェクトは、`配列`と`辞書`です。

```
形式：<オブジェクト>を<関数(条件)>で絞り込む。
```

_例：_

```
配列【１、２0、３、４0、５】を、関数【入力が数値で、数値が10より大きい】で絞り込む。(配列【20、40】)
辞書【「あ」が１、「い」が２、「う」が30】を、関数【入力がキーと値で、値が10より大きい】で絞り込む。(辞書【「う」が30】)
```

注：辞書の場合、関数の入力は２つ(キーと値)必要です。

#### `まとめる`(Reduce)

<オブジェクト>の要素を<初期値>と<関数>で一つにまとめます。  
対象となるオブジェクトは、`配列`と`辞書`と`範囲`です。

```
形式：<オブジェクト>を<初期値>と<関数>でまとめる。
```

_例：_

```
配列【「あ」、「い」、「う」、「え」、「お」】を、「」と関数【入力が初期値と文字で、初期値に文字を足す】でまとめる。(「あいうえお」)
辞書【１が「１」、２が「２」、３が「３」、４が「４」、５が「５」】を、0と関数【入力が初期値とキーと値で、初期値にキーを足す】でまとめる。(15)
範囲【1から5まで】を、０と関数【入力が初期値と数値で、初期値に数値を足す】でまとめる。(15)
```

注：辞書の場合、関数の入力は２つ(キーと値)必要です。

#### `並べ替える`(Sort)

オブジェクトの要素を指定順に並べ替えます。  
対象となるオブジェクトは、`配列`です。また、対象となる要素は、`数値`または`文字列`です。

```
形式１：<配列>を<関数>で並べ替える。(要素を関数で定義した順に並べ替えます。)
形式２：<配列>を「昇順」に並べ替える。(要素を昇順に並べ替えます。)
形式３：<配列>を「降順」に並べ替える。(要素を降順に並べ替えます。)
形式４：<配列>を並べ替える。(要素を昇順に並べ替えます。)
```

_例：_

```
配列【３、１、４、２、５】を並べ替える。(配列【１、２、３、４、５】)
配列【「お」、「い」、「え」、「う」、「あ」】を「昇順」に並べ替える。(配列【「あ」、「い」、「う」、「え」、「お」】)
配列【３、１、４、２、５】を「降順」に並べ替える。(配列【５、４、３、２、１】)
配列【３、１、４、２、５】を、関数【入力が甲と乙で、甲が乙より大きい】で並べ替える。(配列【５、４、３、２、１】)
```

#### `逆順`(Reverse)

```
形式：<オブジェクト>を逆順にする。
```

<オブジェクト>の要素を逆順に並べ替えます。  
対象となるオブジェクトは、`配列`と`文字列`です。

_例：_

```
配列【３、１、４、２、５】を逆順にする。(配列【5,2,4,1,3】)
「いろはにほへと」を逆順にする。(「とへほにはろい」)
```

### コンソール、音声の出力

#### `表示`(Print)と`改行`(Newline)、`尋ねる`(Input)

`表示`(print)は、コンソールにテキストを出力します。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)を表示。
```

助詞`と`で区切られた<オブジェクト>を表示します。各オブジェクト間は、改行されます。

また、述語`改行`(newline)は、改行をします。

_文字列の表示例：_

```
「みなさん、こんにちは。」を表示する。(みなさん、こんにちは。)
「みなさん、」と「こんにちは。」を表示する。(
みなさん、
こんにちは。
)
「みなさん、」に「こんにちは。」を足して表示。(みなさん、こんにちは。)
```

さらに、述語`尋ねる`は、コンソールにテキストを表示し、キーボードの入力を受け付けます。  
改行後に、入力された文字列は、スタックに格納されます。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)と尋ねる。
```

(注：尋ねる問いがない場合、`「」と尋ねる`としてください。)

ここで、表示するオブジェクトに関しては、`表示`と同じです。

_`尋ねる`の例(コンソールのイメージ)：_

```
>> 「入力してください。」と尋ねる。
入力してください。
入力した文字列
入力: (入力した文字列)
>>
```

「入力してください。」に対し、「入力した文字列」を入力した結果、スタックに「入力した文字列」が格納されています。

#### 文字列の表示/エスケープ文字

文字列には、以下の形式１から形式１１の様な、**エスケープ文字**(escape sequence)を含むことができます。

```
形式１：\改行なし (改行を抑止する)
形式２：\末尾 (改行の代わりに以降の文字を表示する)
```

`\改行なし`を文字列に入れることにより、改行を抑止することができます。  
また、`\末尾`は、文字列の改行の代わりに指定した文字を表示します。

_`\改行なし`の例：_

```
「こんにちは、\改行なし」と「みなさん。」を表示する。(こんにちは、みなさん。)
```

さらに、他のコンピュータ言語で使用される以下のエスケープ文字も使用可能です。

```
形式３：\n (改行。ラインフィード)
形式４：\r (改行。キャリッジリターン)
形式５：\t (タブ)
形式６：\\ (バックスラッシュ)
形式７：\0 (null文字)
```

_エスケープ文字の例：_

```
(1)「い\nろ\nは」を表示する。(
い
ろ
は
)
(2)「あ\末尾\t」と「いうえお」を表示する。(あ	いうえお)
```

(２)の例では、「あ」の後の改行の代わりに、`\t`(タブ)を表示しています。

さらに、以下のエスケープ文字により、文字列の中に識別子の内容(定義)を取り込むことも可能です。

```
形式８：\『<識別子>』
形式９：\（<識別子>）
```

注：かっこ`()`は、全角・半角共に可です。
例については、[次項](#定義内容の表示)を参照。

かぎ括弧`「」`を文字列として表示するためには、以下の様に指定します。

```
形式１０：\「
形式１１：\」
```

#### 定義内容の表示

定義した識別子の内容(値や定義)を表示することができます。

_識別子の表示例：_

```
二倍は、関数【入力がxで、xに2を掛ける】。
二倍を表示する。(関数であって、【入力が、xであり、本体が、xに2を掛ける】)
２を二倍し、表示。(4)
※
曜日は、列挙【月は「月曜」と、火は「火曜」、水は「水曜」、木は「木曜」、金は「金曜」、土は「土曜」、日は「日曜」】。
曜日を表示する。(列挙であって、【要素が、月と、火と、水と、木と、金と、土と、日】)
・月を表示する。(列挙型名は曜日で、列挙子は月、値は月曜。)
```

注： `算出`を定義した識別子を表示すると、`算出`が先に実行されるため、定義を表示することはできません。

`算出`の定義内容を表示するためには、述語`識別子`を使います。

_算出の表示例：_

```
加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。

(1) 加えるを表示。(エラー：入力の数が足りていない。必要数：2)
(2) 識別子「加える」を表示。(算出であって、【取得は、【入力が、a「数値」とb「数値」であり、本体が、aにbを足し、返す】】)
(3) 「『加える』は、\『加える』」を表示。(『加える』は、算出であって、【取得は、【入力が、a「数値」とb「数値」であり、本体が、aにbを足し、返す】】)
```

(1)のように、`識別子`をつけないと、`加える`が実行され、引数がないためエラーになります。  
また、(3)のように、エスケープ文字で`識別子`を表示する場合は、`加える`は実行されません。

また、識別子の定義内容にエスケープ文字が含まれ、それを無効化して表示したい場合も、`識別子`を使います。

_スケエープ文字の無効化の例：_

```
文字列は、「い\nろ\nは」。
(4) 識別子「文字列」を表示する。(い\nろ\nは)
(5) 文字列を表示する。(
い
ろ
は
)
```

(4)のように、`識別子`をつけることにより、エスケープ文字`\n`による改行が抑止されます。

注： 述語`ファイル`([`ファイル`を参照](#ファイルfile))を使って、ファイルの内容を表示する場合も、エスケープ文字は無効です。

#### `音読`(Read)

`音読`(read)は、テキストを音声で読み上げます。

```
形式：<オブジェクト１>(と<オブジェクト２>と...)を音読
```

助詞`と`で区切られた<オブジェクト>を音読します。エスケープ文字は無効です(作用しない)。

_音読の例：_

```
「みなさん、こんにちは」を音読する。
```

<識別子>の内容(定義内容)も、表示と同じ様に音読します。

_識別子の音読例：_

```
加えるは、算出【取得が【入力がa「数値」とb「数値」で、aにbを足し、返す】】。
識別子「加える」を音読。
```

また、テキストファイルを音読することも可能です。

_ファイル音読の例：_

```
ファイル「サンプル.txt」を音読する。
```

### ファイル操作

#### `ファイル`(File)

述語`ファイル`(file)により、`/usr/<ユーザ名>/Documents`(「書類」フォルダー)にある、ファイルにアクセスすることが可能です。ファイルに対し可能な処理は、以下のとおりです。  
(注：ディレクトリー(ファオルダー)の位置を変更することはできません。)

```
形式１：ファイル「<ファイル名>」を表示。(コンソールにファイル内容を表示する)
形式２：ファイル「<ファイル名>」を音読。(音声でファイル内容を音読する)
形式３：ファイル「<ファイル名>」を実行。(ファイル内容をプログラムとして実行する)
```

#### `ファイル一覧`(Files)

述語`ファイル一覧`(files)により、`/usr/<ユーザ名>/Documents`(「書類」フォルダー)にある、ファイルの一覧をファイル名(文字列)の`配列`にします。

```
形式：ファイル一覧
```

_ファイル一覧の例：_

```
ファイル一覧を表示する。(ファイル一覧の配列を表示します。)
ファイル一覧を反復【入力がファイル名で、ファイル名を表示する】。(ファイル一覧を、ファイル名ごとに改行して表示する。)
```

### スタック操作

スタックは、予約語の述語、関数、算出、型の初期化の引数として使われます。これら述語等は、引数をチェック、操作して必要な入力とする機構を備えているため、通常は、スタックを操作する必要はありません。  
プログラムの動作確認や、組み込まれた機構で実現できない場合に、以下の述語を使います。

#### `積む`(Push)と`得る`(Pull)と`写す`(Duplicate)

- `積む`は、引数の値をスタックに格納します。複数の引数を格納することはできません。

```
形式：<値>を積む
```

_`積む`の例：_

```
(1) 1を積む。(1)
(2) 1と２に３を４が５を積む。(1と 2に 3を 4が 5)
```

(２)の例は、「５を積む」以外は、助詞(格)の付いた句の状態でスタックに格納されています。

- `得る`は、スタックから値を取り出し、返します。

```
形式１：(「<識別子１>」(「<識別子２>」…)に)(n個)得る。
形式２：(「<識別子１>」(「<識別子２>」…)に)「値」を(n個)得る。
形式３：(「<識別子１>」(「<識別子２>」…)に)「数値」を(n個)得る。
```

注： 識別子が既存の場合、かぎ括弧`「」`は不要です。

1. 「<識別子>」を指定すると、<識別子>にスタックから値を取得する。
1. 「値」を指定すると、スタックから(格を除いた)値を取り出す。
1. 「数値」を指定すると、スタックから数値を取り出す。(無い場合は、無)
1. 個数を指定(n 個)すると、指定数分をスタックから値を取得する。複数の値に対し、１つの識別子を指定した場合、配列に値を取得し、識別子に代入する。指定個数を取得できない場合、`無`を返す。
1. 複数の識別子を指定した場合、識別子ごとに値を代入する。(指定個数があっても無視)

_`得る`の例：_

```
1を積む。甲は得たもの。甲。(1。甲に１が代入され、スタックは空になる。)
2を積む。「甲」に得る。甲。(2。甲に２が代入され、スタックは空になる。)
13 14 15を積む。「甲」に３個得る。甲。(配列【13, 14, 15】)
16を積む。甲は3個得たもの。甲。(無)
17と18を積む。捨てる。「甲」に「数値」を得る。甲。(17)
「a」を積む。甲は「数値」を得たもの。甲。(無)
23と24を積む。「甲」と「乙」に得る。甲に乙を足す。(47)
```

- `写す`は、スタックから値をコピーし返します。形式は`得る`と同じです。

```
形式１：(「<識別子１>」(と「<識別子２>」…)に)(n個)写す。
形式２：(「<識別子１>」(と「<識別子２>」…)に)「値」を(n個)写す。
形式３：(「<識別子１>」(と「<識別子２>」…)に)「数値」を(n個)写す。
```

_`写す`の例：_

```
10と11と12を積む。「甲」に３個写す。甲。(10と 11と 12 配列【10と、11と、12】。)
※ スタックに積んだ値はそのままで、配列にコピーされた値が甲に代入される。
25と26を積む。「甲」と「乙」に写す。甲から乙を引く。(25と 26 -1)
```

#### `捨てる`（Drop)

スタックの値を(最新のものから)、指定した個数を削除します。指定値がない場合、最新の値を削除します。  
また、スタックの値の数より大きい数を指定した場合、全てを削除します。

```
形式：(<数値>個)捨てる
```

_`捨てる`の例：_

```
１と２と３を積む。(1と 2と 3)
２個捨てる。(1と)
捨てる。()
１と２と３を積む。(1と 2と 3)
５個捨てる。()
```

#### `空`(Empty)

`空`(から)は、スタックを空にします。

```
形式１：空
形式２：空にする。
```

注：[`<オブジェクト>が空`の形式](#値literalとオブジェクトobject)では、オブジェクトの要素が空かの判定をします。

_`空`の例：_

```
１と２と３を積む。(1と 2と 3)
空にする。()
```

#### `入れ替える`(Swap)

```
形式１：<識別子１>と<識別子２>を入れ替える。(２つの識別子の値を入れ替えます。)
形式２：<識別子１>を<識別子２>と入れ替える。(２つの識別子の値を入れ替えます。)
形式３：入れ替える。(２つのスタックの値を入れ替えます。)
```

注：形式３で、スタックの値の格が`と`と`を`である場合、形式１、２として処理されます。また、値が２つない場合は、エラーを返します。

### その他

#### `位置`(Position)

[配列要素のアクセス](#配列要素のアクセス)で、[`代入`](#配列に代入)、および[`上書き`](#上書きoverwrite)時に配列の位置を指定します。

#### `識別子`(Identifier)

[定義内容の表示](#定義内容の表示)で、表示する識別子を指定します。

#### `識別子一覧`(Identifiers)

述語`識別子一覧`(identifiers)により、ローカルの辞書を、識別子(文字列)と定義内容(文字列）の辞書にして返します。

```
形式：識別子一覧
```

_識別子一覧の例：_

```
識別子一覧を表示する。(識別子一覧の辞書を表示します。)
識別子一覧で関数【入力がキーと値で、キーを表示する】を繰り返す。(識別子一覧を一行ずつ表示する。)
識別子一覧で関数【入力がキーと定義で、「\(キー)は、\(定義)」を表示する】を繰り返す。(ローカル辞書の、識別子とその定義を表示する。)
```

#### `する`(`し`)

直前のオブジェクトが、`関数`(または`関数`を含む`句`)である場合、その関数を実行します。([関数の実行](#関数の実行function-call)参照。)

直前のオブジェクトが、`関数`でない場合、オブジェクトの値を取り出し、返します。オブジェクトがスタックにない場合は、何もしません。  
これにより、予約語の様に本来、`する`が不要な述語でも、`する`をつなげて問題ありません。(例：`追加する`、`空にする`。)

注：文の中で、オブジェクトを返す(スタックに格納する)述語がない場合、上記の後者の動作をするため、それ以前のスタックのオブジェクトに`する`が作用する場合があります。

_例：_

```
挨拶は、型であって、【
    型の要素が、【宛名は、「田中」。本文は、算出【「こんにちは、」と宛名と「さん。」を足す】】。
】。
挨拶の要素「宛名」を「佐藤」に設定した挨拶の本文。(「こんにちは、佐藤さん。」)
挨拶の要素「宛名」を「鈴木」に設定した挨拶の本文。(こんにちは、佐藤さん。た こんにちは、鈴木さん。)
```

例の最後の文`挨拶の要素「宛名」を「鈴木」に設定`は、値を返さないため、`し`(する)が、直前のオブジェクト`「こんにちは、佐藤さん。」`を返したことにより、次の助詞`た`をつなげ`句`を作っています。

#### `もの`

直前のオブジェクトから値を取り出し、続く助詞をつなげ句を作ります。  
 `もの`を使うと、式を、まとまった句(例では`10と2を掛けたものを`)の様に見せることができるため、可読性が良くなります。

以下の例では、１つ目の`もの`を評価した時点で`5に、10と2を掛けたものを`が、`5に20を`になります。この評価順に記述すると、以下の様になります。(かっこ内は、スタックのデータイメージ)

1.  5 に → (5 に)
1.  10 と → (5 に 10 と)
1.  2 を → (5 に 10 と 2 を)
1.  掛けた → (5 に 20)
1.  ものを → (5 に 20 を)

_述語`もの`の例：_

```
5に、10と2を掛け、足し、15を3で割り、足し、2を掛け、-10を足す。(50)
5に、10と2を掛けたものを足し、15を3で割ったものを足し、2を掛け、-10を足す。(50)
```

数式で書くと、$(5+(10*2)+(15/3))*2+(-10)=50$になります。
上記例の２つの記述は同じ演算になりますが、`もの`を使うことにより読みやすくなります。

#### `および`、`か`、`こと`（Non Operation Code)

他に作用せず、なにもしません。記述を補助するために使います。

_例：_

```
１、および、２、３、４で関数【入力が、aとbとcとd。aとbとcとdを足す】を実行する。(10)
二倍とは、関数【入力がx。xに2を掛ける】こと。
```

注：助詞`とは`は`は`と同じです。
